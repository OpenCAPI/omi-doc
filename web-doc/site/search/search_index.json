{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OMI Overview OMI , stands for Open Memory Interface. Check OMI web site at https://openmemoryinterface.org/open-projects/ OMI is a highly tuned bus that was developed for near memory and is easily migratable to emerging memory solutions (e.g., Storage Class Memory). This serial coherent bus, a subset of OpenCAPI (3.1 version), was architected specifically for the interface between a processor and Near Memory having absolute minimum latency with significant bandwidth and capacity. OMI is the solution to our evolving industry\u2019s demand for Near Memory as data centers evolve from compute centric to becoming data centric. Due to the smaller beachfront required by the OMI serial interface, processors using OMI are able to support many more memory channels. For example, IBM's Power10 is the first processor offering 1 Terabyte/s bandwidth on the memory side. The same bandwidth with external hardware is able to support up to 2 Petabytes of addressable memory. Thanks to the very low latency, this OMI near-memory connection brings plenty of new memory disaggregation possibilities. \"Memory inception\" for example, allows a process to borrow host memory from another server. \"Pool of memories\" can now be built to optimize the sharing of the most expensive resource of our servers. Using this CAPI/OpenCAPI technology associated with FPGAs has not only solved unbelievable bottlenecks, but has drastically decreased the power consumption of previous solutions. This Documentation site presents an overview of host and device chips as well as an enablement guide. Fire host design example Ice device design example Gemini device card design example OMI Enablement Guide All the code and related materials are contributed to different Github repositories. REFERENCE DOCUMENTS and GUIDES DDIMM PMICs information available in the JEDEC Standard Document JESD301-1A DDIMM EEPROM content \"JEDEC Publication No. 106BE : STANDARD MANUFACTURER\u2019S IDENTIFICATION CODE\" JEP106BE.pdf FMC+ OMI ENABLEMENT GUIDE https://github.com/OpenCAPI/omi_enablement/ contains an example of host on a FMC+ board to evaluate DDMIMs modules HOST SIDE FPGA REFERENCE DESIGN https://github.com/OpenCAPI/omi_host_fire contains a host FPGA reference design DEVICE SIDE FPGA REFERENCE DESIGN https://github.com/OpenCAPI/omi_device_ice contains a device FPGA reference design DEVICE SIDE ASIC REFERENCE DESIGN https://github.com/OpenCAPI/omi_asic_device_reference_design contains an ASIC device reference design","title":"Overview"},{"location":"#omi-overview","text":"OMI , stands for Open Memory Interface. Check OMI web site at https://openmemoryinterface.org/open-projects/ OMI is a highly tuned bus that was developed for near memory and is easily migratable to emerging memory solutions (e.g., Storage Class Memory). This serial coherent bus, a subset of OpenCAPI (3.1 version), was architected specifically for the interface between a processor and Near Memory having absolute minimum latency with significant bandwidth and capacity. OMI is the solution to our evolving industry\u2019s demand for Near Memory as data centers evolve from compute centric to becoming data centric. Due to the smaller beachfront required by the OMI serial interface, processors using OMI are able to support many more memory channels. For example, IBM's Power10 is the first processor offering 1 Terabyte/s bandwidth on the memory side. The same bandwidth with external hardware is able to support up to 2 Petabytes of addressable memory. Thanks to the very low latency, this OMI near-memory connection brings plenty of new memory disaggregation possibilities. \"Memory inception\" for example, allows a process to borrow host memory from another server. \"Pool of memories\" can now be built to optimize the sharing of the most expensive resource of our servers. Using this CAPI/OpenCAPI technology associated with FPGAs has not only solved unbelievable bottlenecks, but has drastically decreased the power consumption of previous solutions. This Documentation site presents an overview of host and device chips as well as an enablement guide. Fire host design example Ice device design example Gemini device card design example OMI Enablement Guide All the code and related materials are contributed to different Github repositories.","title":"OMI Overview"},{"location":"#reference-documents-and-guides","text":"DDIMM PMICs information available in the JEDEC Standard Document JESD301-1A DDIMM EEPROM content \"JEDEC Publication No. 106BE : STANDARD MANUFACTURER\u2019S IDENTIFICATION CODE\" JEP106BE.pdf","title":"REFERENCE DOCUMENTS and GUIDES"},{"location":"#fmc-omi-enablement-guide","text":"https://github.com/OpenCAPI/omi_enablement/ contains an example of host on a FMC+ board to evaluate DDMIMs modules","title":"FMC+ OMI ENABLEMENT GUIDE"},{"location":"#host-side-fpga-reference-design","text":"https://github.com/OpenCAPI/omi_host_fire contains a host FPGA reference design","title":"HOST SIDE FPGA REFERENCE DESIGN"},{"location":"#device-side-fpga-reference-design","text":"https://github.com/OpenCAPI/omi_device_ice contains a device FPGA reference design","title":"DEVICE SIDE FPGA REFERENCE DESIGN"},{"location":"#device-side-asic-reference-design","text":"https://github.com/OpenCAPI/omi_asic_device_reference_design contains an ASIC device reference design","title":"DEVICE SIDE ASIC REFERENCE DESIGN"},{"location":"blocs/apollo/","text":"Apollo Description Description This \"Apollo\" card was developed for use in doing post-silicon validation of OMI memory buffers as well as various DDIMM provider without the need for having an actual processor piece of silicon to drive the OMI traffic. The \"Apollo\" card hosts an FPGA containing \"FIRE\" OMI host side FPGA reference design .","title":"APOLLO Card (Host) Description"},{"location":"blocs/apollo/#apollo-description","text":"","title":"Apollo Description"},{"location":"blocs/apollo/#description","text":"This \"Apollo\" card was developed for use in doing post-silicon validation of OMI memory buffers as well as various DDIMM provider without the need for having an actual processor piece of silicon to drive the OMI traffic. The \"Apollo\" card hosts an FPGA containing \"FIRE\" OMI host side FPGA reference design .","title":"Description"},{"location":"blocs/c_code/","text":"C Enablement Software Description Architecture Details OMI enablement platform requires software to configure/synchronize/exercise the host and the DDIMMs modules. Initial development was performed using IBM's Cronus tool and can still be used if required. To ease the discovery of OMI technology, a simple C code has been developed. It can be run either on a external Raspberry pi, or any computer providing an I2C acces to the VCU128 card or on an internal Microblaze microprocessor (under development) Requirements \"smbus2\" librairies are required. General knowledge of C configuration on chosen hardware/OS as well as I2C skills are required. Source code is available here Compilation For example on a raspberry pi : gcc *.c -o omirpi.out General Preparation and Settings ./omirpi.out --help For a verbose display of any command, add the --log option just after omi.py ./omirpi.out --log yourcommand With any command, the I2C bus must be provided with -b option. If you are using a different I2C bus number, the number should be passed like this: ./omirpi.out anycommand -b 3 You can scan the I2C bus with the command: ./omirpi.out scan -b 3 Warning ! Code is provided as is, if unexpected I2C lanes hangs occur, a complete reset of Fire might be required Adapter card Mux settings To be able to access a ddimm from I2C, muxes need to be configured: ./omirpi.out initpath -d ddimm # ddimm : I2C selected DDIMM . Can be a,b,none. ./omirpi.out initpath -d a ./omirpi.out initpath -d b ./omirpi.out initpath -d none At any time, you can check the current path already set up with: ./omirpi.out checkpath Initialize device Before using the following functions, use the following command to initialize the host, without it, i2c errors will be encountered: ./omirpi.out init Host/device information To print out information about a chip, just do: ./omirpi.out info -c chip # chip: host/device name. Can be either \"fire\" or \"explorer\" (or \"ice\") ./omirpi.out info -c fire ./omirpi.out info -c explorer ./omirpi.out info -c ice Reseting Device Change reset state of a DDIMM or multiple DDIMMs from fire: ./omirpi.out ddimmreset -d ddimms -s newresetstate ddimms: letters of ddimms selected (Examples: abcdsw, ab, a) newresetstate: on to activate reset mode, off to quit reset mode Example ./omirpi.out ddimmreset -d ab -s on Read a host/device register: ./omirpi.out read -c chip -r regaddr chip: chip name. Can be either fire or explorer (or ice) regaddr: register address given in hex ./omirpi.out read -c fire -r 0x100000000000004 ./omirpi.out read -c explorer -r 0x20b080 ./omirpi.out read -c explorer -r 0x8012811 Write to a host/device register: ./omirpi.out write -c chip -r regaddr -d data chip: chip name. Can be either fire or explorer (or ice) regaddr: register address given in hex data: new value to write to the register, in hex ./omirpi.out write -c fire -r 0x100000000000004 -d 0x3f ./omirpi.out write -c explorer -r 0x8012811 -d 0x5000000006f Trigger training/synchronisation procedure: ./omirpi.out sync -d ddimms ddimms: letters of ddimms to sync (Examples: ab, b, a) !! This function commutes the muxes automatically to sync the ddims provided. !! Make sure to wait for about 20s after powering/resetting devices before launchig this command, !! otherwise it fails and needs to be re-executed. ./omirpi.out sync -d a ./omirpi.out sync -d b ./omirpi.out sync -d ab To check DDIMM training state: python3 omi.py checksync -d ddimms ddimms: letters of ddimms to sync check (Examples: ab, b, a) python3 omi.py checksync -d a python3 omi.py checksync -d b python3 omi.py checksync -d ab","title":"C Enablement Software Description"},{"location":"blocs/c_code/#c-enablement-software-description","text":"","title":"C Enablement Software Description"},{"location":"blocs/c_code/#architecture-details","text":"OMI enablement platform requires software to configure/synchronize/exercise the host and the DDIMMs modules. Initial development was performed using IBM's Cronus tool and can still be used if required. To ease the discovery of OMI technology, a simple C code has been developed. It can be run either on a external Raspberry pi, or any computer providing an I2C acces to the VCU128 card or on an internal Microblaze microprocessor (under development)","title":"Architecture Details"},{"location":"blocs/c_code/#requirements","text":"\"smbus2\" librairies are required. General knowledge of C configuration on chosen hardware/OS as well as I2C skills are required. Source code is available here","title":"Requirements"},{"location":"blocs/c_code/#compilation","text":"For example on a raspberry pi : gcc *.c -o omirpi.out","title":"Compilation"},{"location":"blocs/c_code/#general-preparation-and-settings","text":"./omirpi.out --help For a verbose display of any command, add the --log option just after omi.py ./omirpi.out --log yourcommand With any command, the I2C bus must be provided with -b option. If you are using a different I2C bus number, the number should be passed like this: ./omirpi.out anycommand -b 3 You can scan the I2C bus with the command: ./omirpi.out scan -b 3 Warning ! Code is provided as is, if unexpected I2C lanes hangs occur, a complete reset of Fire might be required","title":"General Preparation and Settings"},{"location":"blocs/c_code/#adapter-card-mux-settings","text":"To be able to access a ddimm from I2C, muxes need to be configured: ./omirpi.out initpath -d ddimm # ddimm : I2C selected DDIMM . Can be a,b,none. ./omirpi.out initpath -d a ./omirpi.out initpath -d b ./omirpi.out initpath -d none At any time, you can check the current path already set up with: ./omirpi.out checkpath","title":"Adapter card Mux settings"},{"location":"blocs/c_code/#initialize-device","text":"Before using the following functions, use the following command to initialize the host, without it, i2c errors will be encountered: ./omirpi.out init","title":"Initialize device"},{"location":"blocs/c_code/#hostdevice-information","text":"To print out information about a chip, just do: ./omirpi.out info -c chip # chip: host/device name. Can be either \"fire\" or \"explorer\" (or \"ice\") ./omirpi.out info -c fire ./omirpi.out info -c explorer ./omirpi.out info -c ice","title":"Host/device information"},{"location":"blocs/c_code/#reseting-device","text":"","title":"Reseting Device"},{"location":"blocs/c_code/#change-reset-state-of-a-ddimm-or-multiple-ddimms-from-fire","text":"./omirpi.out ddimmreset -d ddimms -s newresetstate ddimms: letters of ddimms selected (Examples: abcdsw, ab, a) newresetstate: on to activate reset mode, off to quit reset mode","title":"Change reset state of a DDIMM or multiple DDIMMs from fire:"},{"location":"blocs/c_code/#example","text":"./omirpi.out ddimmreset -d ab -s on","title":"Example"},{"location":"blocs/c_code/#read-a-hostdevice-register","text":"./omirpi.out read -c chip -r regaddr chip: chip name. Can be either fire or explorer (or ice) regaddr: register address given in hex ./omirpi.out read -c fire -r 0x100000000000004 ./omirpi.out read -c explorer -r 0x20b080 ./omirpi.out read -c explorer -r 0x8012811","title":"Read a host/device register:"},{"location":"blocs/c_code/#write-to-a-hostdevice-register","text":"./omirpi.out write -c chip -r regaddr -d data chip: chip name. Can be either fire or explorer (or ice) regaddr: register address given in hex data: new value to write to the register, in hex ./omirpi.out write -c fire -r 0x100000000000004 -d 0x3f ./omirpi.out write -c explorer -r 0x8012811 -d 0x5000000006f","title":"Write to a host/device register:"},{"location":"blocs/c_code/#trigger-trainingsynchronisation-procedure","text":"./omirpi.out sync -d ddimms ddimms: letters of ddimms to sync (Examples: ab, b, a) !! This function commutes the muxes automatically to sync the ddims provided. !! Make sure to wait for about 20s after powering/resetting devices before launchig this command, !! otherwise it fails and needs to be re-executed. ./omirpi.out sync -d a ./omirpi.out sync -d b ./omirpi.out sync -d ab","title":"Trigger training/synchronisation procedure:"},{"location":"blocs/c_code/#to-check-ddimm-training-state","text":"python3 omi.py checksync -d ddimms ddimms: letters of ddimms to sync check (Examples: ab, b, a) python3 omi.py checksync -d a python3 omi.py checksync -d b python3 omi.py checksync -d ab","title":"To check DDIMM training state:"},{"location":"blocs/enablement/","text":"OMI ENABLEMENT Guide HARDWARE DESCRIPTION For the purpose of open sourcing the design, a collaboration between OMI members led to a tuning of an OMIhost FPGA reference design \" Fire \" to be used in a VCU128 Card from AMD/Xilinx. With addition of a simple FMC+ connected add-on card, any OMI compatible memory DDIMM module can be evaluated. The setup allows evaluation of 2 DDIMMs modules in slots A and B. Some code is required to synchronize and test the OMI DDIMMs. Enablement example codes have been developed in Python and in C. Same functions are available. Either the code is executed in a companion raspberry pi or any I2C capable computer, or even in an embedded microblaze processor (in the latter case use the C version as it executes much faster) Python source code is available at : Python Code Python code documentation is available at : Python Documentation C source code is available at : C Code C code documentation is available at : C Documentation Enablement example code Checks I2C tree Synchronizes DDIMMs Executes simple transfers in memory (not published yet) Note: The Raspberry pi can host an Cronus server, should you want to evaluate OMI in a Cronus environment. REQUIREMENTS Requirements depends on what kind of experiments need to be conducted. Cronus with a raspberry pi hosting a Cronus server and dealing with I2C accesses (out of present scope) Standalone Python or C code running on Raspberry Pi or a PC with I2C capabilities Embedded PetaLinux with Microblaze next to Fire in the FPGA requires TFTP / NFS / DNS server to host boot and file system can run C standalone code (Python is too slow to execute in a timely manner) Standalone C code running on a no-OS Microblaze embedded processor (not developed yet) only requires a serial terminal (can be \"picocom\" using UART through programming USB cable) Minimum Hardware requirements : Procure the following: A VCU128 Board from AMD/Xilinx and a JTAG controlling PC (can be the Raspberry pi) An adapter board from Tormem . as of today only V1 is available Version 1 allows basic DDIMM interface Version 2 will also allow FIRE reset and power control of 12V, 3.3V and 1.8V. At least one DDIMM module A USB relay card to ensure automated fire reset / 3.3V / 12V POWER control (if using an adapter board version 1) Software requirements : Obtain an AMD/Xilinx Licence for Vivado. Requires 2018.3 version for this contribution (best timing results at maximum bandwidth). ENABLEMENT STEPS with an external I2C master git clone the \" vcu128_enablement \" branch of Fire design. First synthetize, implement and generate bitstream of \"FIRE\" design for the VCU128 using the specific branch as specified in the README.md file. git clone the https://github.com/OpenCAPI/omi_enablement/ and use /python or /c directory with a debugging raspberry pi or any computer with I2C capability to check you can see the design. Choose Python or C control, both will send requests through the I2C bus to the Fire design. Explorer chip are usually access through In band commands are dealt by Fire. ENABLEMENT STEPS with internal Microblaze as I2C master When using Tormem adapter board version 1, I2C control by Microblaze requires a hacking of the VCU128 board as there is no provision to connect an external cable. git clone the \" vcu128_enablement \" branch of Fire design. First synthetize, implement and generate bitstream of \"FIRE\" design for the VCU128 using the specific branch as specified in the README.md file. To prepare the integration of FIRE and microblaze structure, generate an IP of Fire design. Git clone the \" omi_enablement \" to get the necessary material to build a {Fire + Microblaze} structure. Hardware: Option 1 : re-create your own design {FIRE + Microblaze} From the \"hw/\" directory, use hw_script.sh and tcl_code.tcl to generate a microblaze environment. you'll be ask to provide the FIRE ip path from step 3. you'll get the .xsa file which is the only file required for the remaining steps. It contains a complete description of the hardware. Hardware Option 2: use pre-built hardware system.bit. Install petalinux (we used the 2021.1 version) Software Option 1: create your petalinux environment using petalinux-create, create a vcuomi project directory. petalinux-create --type project --template microblaze --name vcuomi remaining tasks: To Be described ... Software Option 2: Use pre_built linux Use https://github.com/OpenCAPI/omi_enablement/tree/main/petalinux content run the script.sh and then wsl@wsl:~/omi_enablement/petalinux$ petalinux-create --type project -s *.bsp wsl@wsl:~/omi_enablement/petalinux$ mkdir vcuomi/images && mkdir vcuomi/images/linux wsl@wsl:~/omi_enablement/petalinux$ cp -r linux/images/* vcuomi/images/linux/. copy the images/linux content to your tftp directory of the remote computer acting as a server. From the remote tftp/NFS server: copy the tftp/rootfs.tar.gz directory to your NFS directory. Adjust permissions accordingly. From petalinux installation dir use xsct -nolrwrap to load the system.bit into the fpga. open a picocom or any RS232 terminal on the FPGA RS232 link. trigger a boot of the microblaze with petalinux-boot.","title":"FMC+ ENABLEMENT Description"},{"location":"blocs/enablement/#omi-enablement-guide","text":"","title":"OMI ENABLEMENT Guide"},{"location":"blocs/enablement/#hardware-description","text":"For the purpose of open sourcing the design, a collaboration between OMI members led to a tuning of an OMIhost FPGA reference design \" Fire \" to be used in a VCU128 Card from AMD/Xilinx. With addition of a simple FMC+ connected add-on card, any OMI compatible memory DDIMM module can be evaluated. The setup allows evaluation of 2 DDIMMs modules in slots A and B. Some code is required to synchronize and test the OMI DDIMMs. Enablement example codes have been developed in Python and in C. Same functions are available. Either the code is executed in a companion raspberry pi or any I2C capable computer, or even in an embedded microblaze processor (in the latter case use the C version as it executes much faster) Python source code is available at : Python Code Python code documentation is available at : Python Documentation C source code is available at : C Code C code documentation is available at : C Documentation Enablement example code Checks I2C tree Synchronizes DDIMMs Executes simple transfers in memory (not published yet) Note: The Raspberry pi can host an Cronus server, should you want to evaluate OMI in a Cronus environment.","title":"HARDWARE DESCRIPTION"},{"location":"blocs/enablement/#requirements","text":"Requirements depends on what kind of experiments need to be conducted. Cronus with a raspberry pi hosting a Cronus server and dealing with I2C accesses (out of present scope) Standalone Python or C code running on Raspberry Pi or a PC with I2C capabilities Embedded PetaLinux with Microblaze next to Fire in the FPGA requires TFTP / NFS / DNS server to host boot and file system can run C standalone code (Python is too slow to execute in a timely manner) Standalone C code running on a no-OS Microblaze embedded processor (not developed yet) only requires a serial terminal (can be \"picocom\" using UART through programming USB cable) Minimum Hardware requirements : Procure the following: A VCU128 Board from AMD/Xilinx and a JTAG controlling PC (can be the Raspberry pi) An adapter board from Tormem . as of today only V1 is available Version 1 allows basic DDIMM interface Version 2 will also allow FIRE reset and power control of 12V, 3.3V and 1.8V. At least one DDIMM module A USB relay card to ensure automated fire reset / 3.3V / 12V POWER control (if using an adapter board version 1) Software requirements : Obtain an AMD/Xilinx Licence for Vivado. Requires 2018.3 version for this contribution (best timing results at maximum bandwidth).","title":"REQUIREMENTS"},{"location":"blocs/enablement/#enablement-steps-with-an-external-i2c-master","text":"git clone the \" vcu128_enablement \" branch of Fire design. First synthetize, implement and generate bitstream of \"FIRE\" design for the VCU128 using the specific branch as specified in the README.md file. git clone the https://github.com/OpenCAPI/omi_enablement/ and use /python or /c directory with a debugging raspberry pi or any computer with I2C capability to check you can see the design. Choose Python or C control, both will send requests through the I2C bus to the Fire design. Explorer chip are usually access through In band commands are dealt by Fire.","title":"ENABLEMENT STEPS with an external I2C master"},{"location":"blocs/enablement/#enablement-steps-with-internal-microblaze-as-i2c-master","text":"When using Tormem adapter board version 1, I2C control by Microblaze requires a hacking of the VCU128 board as there is no provision to connect an external cable. git clone the \" vcu128_enablement \" branch of Fire design. First synthetize, implement and generate bitstream of \"FIRE\" design for the VCU128 using the specific branch as specified in the README.md file. To prepare the integration of FIRE and microblaze structure, generate an IP of Fire design. Git clone the \" omi_enablement \" to get the necessary material to build a {Fire + Microblaze} structure. Hardware: Option 1 : re-create your own design {FIRE + Microblaze} From the \"hw/\" directory, use hw_script.sh and tcl_code.tcl to generate a microblaze environment. you'll be ask to provide the FIRE ip path from step 3. you'll get the .xsa file which is the only file required for the remaining steps. It contains a complete description of the hardware. Hardware Option 2: use pre-built hardware system.bit. Install petalinux (we used the 2021.1 version) Software Option 1: create your petalinux environment using petalinux-create, create a vcuomi project directory. petalinux-create --type project --template microblaze --name vcuomi remaining tasks: To Be described ... Software Option 2: Use pre_built linux Use https://github.com/OpenCAPI/omi_enablement/tree/main/petalinux content run the script.sh and then wsl@wsl:~/omi_enablement/petalinux$ petalinux-create --type project -s *.bsp wsl@wsl:~/omi_enablement/petalinux$ mkdir vcuomi/images && mkdir vcuomi/images/linux wsl@wsl:~/omi_enablement/petalinux$ cp -r linux/images/* vcuomi/images/linux/. copy the images/linux content to your tftp directory of the remote computer acting as a server. From the remote tftp/NFS server: copy the tftp/rootfs.tar.gz directory to your NFS directory. Adjust permissions accordingly. From petalinux installation dir use xsct -nolrwrap to load the system.bit into the fpga. open a picocom or any RS232 terminal on the FPGA RS232 link. trigger a boot of the microblaze with petalinux-boot.","title":"ENABLEMENT STEPS with internal Microblaze as I2C master"},{"location":"blocs/fire/","text":"FIRE Description Description Fire is an OMI host FPGA reference design based on the OpenCAPI 3.1 Transaction and Data Layer Architecture Specification . The design was developed to be used in an \" Apollo \" card. This \" Apollo \" card was developed for use in doing post-silicon validation of OMI memory buffers as well as various DDIMM provider without the need for having an actual processor piece of silicon to drive the OMI traffic. A branch \" vcu128_enablement \" has been created to allow usage of Fire in a VCU128 board with a FMC+ connector and an adaptation board. Check for enablement information on the enablement page","title":"FIRE Host Side FPGA Description"},{"location":"blocs/fire/#fire-description","text":"","title":"FIRE Description"},{"location":"blocs/fire/#description","text":"Fire is an OMI host FPGA reference design based on the OpenCAPI 3.1 Transaction and Data Layer Architecture Specification . The design was developed to be used in an \" Apollo \" card. This \" Apollo \" card was developed for use in doing post-silicon validation of OMI memory buffers as well as various DDIMM provider without the need for having an actual processor piece of silicon to drive the OMI traffic. A branch \" vcu128_enablement \" has been created to allow usage of Fire in a VCU128 board with a FMC+ connector and an adaptation board. Check for enablement information on the enablement page","title":"Description"},{"location":"blocs/gemini/","text":"Gemini Description Description Gemini is a development card hosting an ICE OMI device side FPGA reference design and connected to a server DIMM connector. It enables attachment of a DDR4 memory through OMI. It was developed for use in doing post-silicon validation of a CPU that has OMI near memory controller implementations.","title":"GEMINI Card (Device) Description"},{"location":"blocs/gemini/#gemini-description","text":"","title":"Gemini Description"},{"location":"blocs/gemini/#description","text":"Gemini is a development card hosting an ICE OMI device side FPGA reference design and connected to a server DIMM connector. It enables attachment of a DDR4 memory through OMI. It was developed for use in doing post-silicon validation of a CPU that has OMI near memory controller implementations.","title":"Description"},{"location":"blocs/ice/","text":"ICE Description Description Ice is an OMI device side FPGA reference design based on the OpenCAPI 3.1 Transaction and Data Layer Architecture Specification . The design was developed to be used in an \" Gemini \" card. This \" Gemini \" card was developed for use in doing post-silicon validation of a CPU that has OMI near memory controller implementations.","title":"ICE Device Side FPGA Description"},{"location":"blocs/ice/#ice-description","text":"","title":"ICE Description"},{"location":"blocs/ice/#description","text":"Ice is an OMI device side FPGA reference design based on the OpenCAPI 3.1 Transaction and Data Layer Architecture Specification . The design was developed to be used in an \" Gemini \" card. This \" Gemini \" card was developed for use in doing post-silicon validation of a CPU that has OMI near memory controller implementations.","title":"Description"},{"location":"blocs/python/","text":"Python Enablement Software Description Architecture Details OMI enablement platform requires software to configure/synchronize/exercise the host and the DDIMMs modules. Initial development was performed using IBM's Cronus tool and can still be used if required. To ease the discovery of OMI technology, a simple python code has been developed. It can be run either on a external Raspberry pi, or any computer providing an I2C acces to the VCU128 card or on an internal Microblaze microprocessor (under development) Requirements \"click\" and \"smbus2\" librairies are required. General knowledge of python configuration on chosen hardware/OS as well as I2C skills are required. Source code is available here General Preparation and Settings This application is run from CLI (Command Line Interface) with Python3: python3 omi.py --help For a verbose display of any command, add the --log option just after omi.py python3 omi.py --log yourcommand With any command, the I2C bus can be provided with -b option. By default I2C bus is set to 3 if not given. If you are using a different I2C bus number, the number should be passed like this: python3 omi.py anycommand -b 1 You can scan the I2C bus with the command: python3 omi.py scan -b 3 Warning ! Code is provided as is, if unexpected I2C lanes hangs occur, a complete reset of Fire might be required Adapter card Mux settings To be able to access a ddimm from I2C, muxes need to be configured: python3 omi.py initpath -d ddimm # ddimm : I2C selected DDIMM . Can be a,b,none. python3 omi.py initpath -d a python3 omi.py initpath -d b python3 omi.py initpath -d none At any time, you can check the current path already set up with: python3 omi.py checkpath Initialize device Before using the following functions, use the following command to initialize the host, without it, i2c errors will be encountered: python3 omi.py init Host/device information To print out information about a chip, just do: python3 omi.py info -c chip # chip: host/device name. Can be either \"fire\" or \"explorer\" (or \"ice\") python3 omi.py info -c fire python3 omi.py info -c explorer python3 omi.py info -c ice Reseting Device Change reset state of a DDIMM or multiple DDIMMs from fire: python3 omi.py ddimmreset -d ddimms -s newresetstate ddimms: letters of ddimms selected (Examples: abcdsw, ab, a) newresetstate: on to activate reset mode, off to quit reset mode Example python3 omi.py ddimmreset -d ab -s on Read a host/device register: python3 omi.py read -c chip -r regaddr chip: chip name. Can be either fire or explorer (or ice) regaddr: register address given in hex python3 omi.py read -c fire -r 0x100000000000004 python3 omi.py read -c explorer -r 0x20b080 python3 omi.py read -c explorer -r 0x8012811 Write to a host/device register: python3 omi.py write -c chip -r regaddr -d data chip: chip name. Can be either fire or explorer (or ice) regaddr: register address given in hex data: new value to write to the register, in hex python3 omi.py write -c fire -r 0x100000000000004 -d 0x3f python3 omi.py write -c explorer -r 0x8012811 -d 0x5000000006f Trigger training/synchronisation procedure: python3 omi.py sync -d ddimms ddimms: letters of ddimms to sync (Examples: ab, b, a) !! This function commutes the muxes automatically to sync the ddims provided. !! Make sure to wait for about 20s after powering/resetting devices before launchig this command, !! otherwise it fails and needs to be re-executed. python3 omi.py sync -d a python3 omi.py sync -d b python3 omi.py sync -d ab Trigger DDIMM Configuration procedure: python3 omi.py ddimmcfg -d ddimms ddimms: letters of ddimms to sync (Examples: ab, b, a) This function will trigger a configuration process with Fire commands (Explorer will be accessed through In-band commands) No need to select the MUX path, as only Fire receives I2C commands. python3 omi.py ddimmcfg -d a python3 omi.py ddimmcfg -d b python3 omi.py ddimmcfg -d ab To check DDIMM training state: python3 omi.py checksync -d ddimms ddimms: letters of ddimms to sync check (Examples: ab, b, a) python3 omi.py checksync -d a python3 omi.py checksync -d b python3 omi.py checksync -d ab Examples of Usage python3 omi.py initpath -d a python3 omi.py init python3 omi.py sync -d a python3 omi.py info -c explorer python3 omi.py checkpath pi@raspberrypi:~/python $ python3 omi.py initpath -d a pi@raspberrypi:~/python $ python3 omi.py init pi@raspberrypi:~/python $ python3 omi.py sync -d a ---------- : Explorer Initialisation ------------ Explorer Firmware API version: 0x0f Ready Sync DDIMMA... ---------- Explorer OMI Training Sequence ------------ ---------- Fire OMI Training Sequence ------------ DDIMMA sync Reg: 0x8000000000 Training successfully done. pi@raspberrypi:~/python $ python3 omi.py ddimmcfg -d a Configuring DDIMMA... DDIMMA Configuration Memory Size : 64GB Vendor : SMART Memory Size : 64GB Vendor : SMART pi@raspberrypi:~/python $ python3 omi.py info -c explorer FW number of images: 0x2 Partition ID: 0x41 Major (Boot Partion A): 0x8 Minor (Boot Partion A): 0x0 Build patch (Boot Partion A): 0x0 Build number (Boot Partion A): 0x6792a Build date (Boot Partion A): 0x2222021 Major (Boot Partion B): 0x8 Minor (Boot Partion B): 0x0 Build patch (Boot Partion B): 0x0 Build number (Boot Partion B): 0x6792a Build date (Boot Partion B): 0x2222021 RAM size (in bytes): 0x40000 Chip version: 0x20600d2 SPI flash ID: 0xbb98 SPI flash sector size: 0x10000 SPI flash size: 0x1000000 Error buffer size: 0x1000 Image index: 0x0 ECID: 0x1000000000000721a6d03b4f8759f0d4ed89300 Entreprise Mode Status: 0x796 Card ID: 0x3e00008 EEPROM data: Reading 0x40c0a8529000800600003080b8000 Memory Size : 32GB","title":"Python Enablement Software Description"},{"location":"blocs/python/#python-enablement-software-description","text":"","title":"Python Enablement Software Description"},{"location":"blocs/python/#architecture-details","text":"OMI enablement platform requires software to configure/synchronize/exercise the host and the DDIMMs modules. Initial development was performed using IBM's Cronus tool and can still be used if required. To ease the discovery of OMI technology, a simple python code has been developed. It can be run either on a external Raspberry pi, or any computer providing an I2C acces to the VCU128 card or on an internal Microblaze microprocessor (under development)","title":"Architecture Details"},{"location":"blocs/python/#requirements","text":"\"click\" and \"smbus2\" librairies are required. General knowledge of python configuration on chosen hardware/OS as well as I2C skills are required. Source code is available here","title":"Requirements"},{"location":"blocs/python/#general-preparation-and-settings","text":"This application is run from CLI (Command Line Interface) with Python3: python3 omi.py --help For a verbose display of any command, add the --log option just after omi.py python3 omi.py --log yourcommand With any command, the I2C bus can be provided with -b option. By default I2C bus is set to 3 if not given. If you are using a different I2C bus number, the number should be passed like this: python3 omi.py anycommand -b 1 You can scan the I2C bus with the command: python3 omi.py scan -b 3 Warning ! Code is provided as is, if unexpected I2C lanes hangs occur, a complete reset of Fire might be required","title":"General Preparation and Settings"},{"location":"blocs/python/#adapter-card-mux-settings","text":"To be able to access a ddimm from I2C, muxes need to be configured: python3 omi.py initpath -d ddimm # ddimm : I2C selected DDIMM . Can be a,b,none. python3 omi.py initpath -d a python3 omi.py initpath -d b python3 omi.py initpath -d none At any time, you can check the current path already set up with: python3 omi.py checkpath","title":"Adapter card Mux settings"},{"location":"blocs/python/#initialize-device","text":"Before using the following functions, use the following command to initialize the host, without it, i2c errors will be encountered: python3 omi.py init","title":"Initialize device"},{"location":"blocs/python/#hostdevice-information","text":"To print out information about a chip, just do: python3 omi.py info -c chip # chip: host/device name. Can be either \"fire\" or \"explorer\" (or \"ice\") python3 omi.py info -c fire python3 omi.py info -c explorer python3 omi.py info -c ice","title":"Host/device information"},{"location":"blocs/python/#reseting-device","text":"","title":"Reseting Device"},{"location":"blocs/python/#change-reset-state-of-a-ddimm-or-multiple-ddimms-from-fire","text":"python3 omi.py ddimmreset -d ddimms -s newresetstate ddimms: letters of ddimms selected (Examples: abcdsw, ab, a) newresetstate: on to activate reset mode, off to quit reset mode","title":"Change reset state of a DDIMM or multiple DDIMMs from fire:"},{"location":"blocs/python/#example","text":"python3 omi.py ddimmreset -d ab -s on","title":"Example"},{"location":"blocs/python/#read-a-hostdevice-register","text":"python3 omi.py read -c chip -r regaddr chip: chip name. Can be either fire or explorer (or ice) regaddr: register address given in hex python3 omi.py read -c fire -r 0x100000000000004 python3 omi.py read -c explorer -r 0x20b080 python3 omi.py read -c explorer -r 0x8012811","title":"Read a host/device register:"},{"location":"blocs/python/#write-to-a-hostdevice-register","text":"python3 omi.py write -c chip -r regaddr -d data chip: chip name. Can be either fire or explorer (or ice) regaddr: register address given in hex data: new value to write to the register, in hex python3 omi.py write -c fire -r 0x100000000000004 -d 0x3f python3 omi.py write -c explorer -r 0x8012811 -d 0x5000000006f","title":"Write to a host/device register:"},{"location":"blocs/python/#trigger-trainingsynchronisation-procedure","text":"python3 omi.py sync -d ddimms ddimms: letters of ddimms to sync (Examples: ab, b, a) !! This function commutes the muxes automatically to sync the ddims provided. !! Make sure to wait for about 20s after powering/resetting devices before launchig this command, !! otherwise it fails and needs to be re-executed. python3 omi.py sync -d a python3 omi.py sync -d b python3 omi.py sync -d ab","title":"Trigger training/synchronisation procedure:"},{"location":"blocs/python/#trigger-ddimm-configuration-procedure","text":"python3 omi.py ddimmcfg -d ddimms ddimms: letters of ddimms to sync (Examples: ab, b, a) This function will trigger a configuration process with Fire commands (Explorer will be accessed through In-band commands) No need to select the MUX path, as only Fire receives I2C commands. python3 omi.py ddimmcfg -d a python3 omi.py ddimmcfg -d b python3 omi.py ddimmcfg -d ab","title":"Trigger DDIMM Configuration procedure:"},{"location":"blocs/python/#to-check-ddimm-training-state","text":"python3 omi.py checksync -d ddimms ddimms: letters of ddimms to sync check (Examples: ab, b, a) python3 omi.py checksync -d a python3 omi.py checksync -d b python3 omi.py checksync -d ab","title":"To check DDIMM training state:"},{"location":"blocs/python/#examples-of-usage","text":"python3 omi.py initpath -d a python3 omi.py init python3 omi.py sync -d a python3 omi.py info -c explorer python3 omi.py checkpath pi@raspberrypi:~/python $ python3 omi.py initpath -d a pi@raspberrypi:~/python $ python3 omi.py init pi@raspberrypi:~/python $ python3 omi.py sync -d a ---------- : Explorer Initialisation ------------ Explorer Firmware API version: 0x0f Ready Sync DDIMMA... ---------- Explorer OMI Training Sequence ------------ ---------- Fire OMI Training Sequence ------------ DDIMMA sync Reg: 0x8000000000 Training successfully done. pi@raspberrypi:~/python $ python3 omi.py ddimmcfg -d a Configuring DDIMMA... DDIMMA Configuration Memory Size : 64GB Vendor : SMART Memory Size : 64GB Vendor : SMART pi@raspberrypi:~/python $ python3 omi.py info -c explorer FW number of images: 0x2 Partition ID: 0x41 Major (Boot Partion A): 0x8 Minor (Boot Partion A): 0x0 Build patch (Boot Partion A): 0x0 Build number (Boot Partion A): 0x6792a Build date (Boot Partion A): 0x2222021 Major (Boot Partion B): 0x8 Minor (Boot Partion B): 0x0 Build patch (Boot Partion B): 0x0 Build number (Boot Partion B): 0x6792a Build date (Boot Partion B): 0x2222021 RAM size (in bytes): 0x40000 Chip version: 0x20600d2 SPI flash ID: 0xbb98 SPI flash sector size: 0x10000 SPI flash size: 0x1000000 Error buffer size: 0x1000 Image index: 0x0 ECID: 0x1000000000000721a6d03b4f8759f0d4ed89300 Entreprise Mode Status: 0x796 Card ID: 0x3e00008 EEPROM data: Reading 0x40c0a8529000800600003080b8000 Memory Size : 32GB","title":"Examples of Usage"},{"location":"misc/doc-guide/","text":"How to generate this website This static documentation website is created by MkDocs and is using a theme from bootswatch . It uses \"github pages\" and this site is hosted by Github. The documentation source files are written in Markdown format. With MkDocs tool, the generated site files (html files) are automatically pushed into a specific branch gh-pages of the git repository. Installation 1. Install python and pip python and pip 2. Install mkdocs-bootswatch pip install mkdocs-bootswatch Please refer to bootswatch for more information. 3. Install a markdown editor You can simply edit the markdown (.md) files by any text editor, but it's better to user a professional markdown editor. typora . It supports all of the platforms (Windows/MacOS/Linux). Please configure typora to strict Markdown mode. That ensures you get the same output effects on both typora and mkdocs . vscode . It's also a good editor and has abundant functions and extensions. You can install extensions of Markdown, Preview and Spell checker. 4. Install other optional tools pdf2svg: This tool can convert a pdf lossless picture to svg format. For Mac OS, it can be easily installed by Homebrew , simply by brew install pdf2svg . Alternative choice is Inkscape which is a free drawing tool and can help you draw and convert vector graphics. Website Structure First, you need to git clone the omi-doc repository and go to web-doc directory. Make sure you are working on a branch other than master. $ git clone git@github.com:OpenCAPI/omi-doc.git $ cd omi-doc/web-doc Create a branch if needed: $ git branch <new-branch-name> $ git checkout <A branch other than master> The docs folder is where to put the markdown files, and the mkdocs.yml lists the website structure and global definitons. For example, this site has a structure like: nav: - Main Elements: - 'Overview': 'index.md' - 'FIRE Description': 'blocs/fire.md' - 'ICE Description': 'blocs/ice.md' - 'GEMINI Description': 'blocs/gemini.md' - 'FMC+ ENABLEMENT Description': 'blocs/enablement.md' - Misc: - 'Document Guide': 'misc/doc-guide.md' You can edit them as needed. Write Markdown pages On your local desktop, edit markdown files under web-doc/docs folder. If you want to add/delete/rename the files, you also need to edit mkdocs.yml Now it's time to work with an editor (i.e, typora) to write the documents. You also may need to learn some markdown syntax. Don't worry, that's easy. And please turn on the \"spell checking\" in your Markdown editor. In your terminal (MacOS or Linux), or cmd (Windows), start a serve process: # enter in the directory where mkdocs.yml is located cd ~/omi-doc/web-doc #launch a local webserver to test your mods mkdocs serve Then open a web browser, input http://127.0.0.1:8000 . So whenever you save any markdown files, you can check the generated website immediately. Play with pictures The first rule Reduce the usage of pictures. Avoid unnecessary screenshots. It's quite easy You can insert jpg, png, svg files. You can also simply copy paste pictures from clipboard and paste them. Copy the files into a directory ./${filename}.assets , and here ${filename} is the name of markdown file. Use relative links in the document. Note If you are using Typora, please enable \"Copy images into ./${filename}.assets folder\" in Preferences of typora. Tools to draw diagrams You can take any drawing tools to create diagrams. You can save them as PNG format, but the better way is to save to SVG format. For the diagrams from Microsoft PowerPoint, you can select the region of a diagram in PPT, Ctrl-C to copy it, and Ctrl-V to paste it in Typora directly. In this case, the diagram is saved as an PNG file. But there is a better way to get the smallest file size and best quality: In PowerPoint, select the region of diagram, right-click mouse -> \"Save as Picture ...\" and save it as \"PDF\" format. Open the PDF file with Inkscape . (Right-click the file -> \"Open with ...\", choose Inkscape in the poped up list). Unclick \"Embed images\" and then \"OK\". In Inkscape, save it as SVG file. Insert the SVG file into Typora. In my experiment, the PNG file is 188KB. But with the above flow to save it as SVG file, its size is 62KB. As a vectored diagram, it doesn't have any quality loss when zooming in. Warning Please use normal fonts in PPT, for example \"Arial\". Otherwise you may get a SVG file with a replaced font and that may look different. Code blocks and Admonitions Code blocks Please assign the code language so it can be correctly rendered. For example ``` C for C language. // A function to implement bubble sort void bubbleSort(int arr[], int n) { int i, j; for (i = 0; i < n-1; i++) // Last i elements are already in place for (j = 0; j < n-i-1; j++) if (arr[j] > arr[j+1]) swap(&arr[j], &arr[j+1]); } Admonitions You can use !!! Note or !!! Warning or !!! Danger to start a paragraph of admonitions. Then use 4 spaces to start the admonition text. For example !!! Danger \"Error Message\" This is a dangerous error. It will be shown as: Error Message This is a dangerous error. Deploy to Github Pages When most of the edition work is done, and it's time to commit your documents to omi-doc github. First, you should commit and push your changes of source files (in web-doc ) to git repository. Create pull request, ask someone to review the documents, merge them into master branch after getting approvements. Then you can simply publish website with just one step: cd <PATH>/omi-doc/web-doc mkdocs gh-deploy The entire website will be pushed to gh-pages branch of omi-doc repository. The documentation website will be available at https://opencapi.github.io/omi-doc/ !","title":"Document Guide"},{"location":"misc/doc-guide/#how-to-generate-this-website","text":"This static documentation website is created by MkDocs and is using a theme from bootswatch . It uses \"github pages\" and this site is hosted by Github. The documentation source files are written in Markdown format. With MkDocs tool, the generated site files (html files) are automatically pushed into a specific branch gh-pages of the git repository.","title":"How to generate this website"},{"location":"misc/doc-guide/#installation","text":"","title":"Installation"},{"location":"misc/doc-guide/#1-install-python-and-pip","text":"python and pip","title":"1. Install python and pip"},{"location":"misc/doc-guide/#2-install-mkdocs-bootswatch","text":"pip install mkdocs-bootswatch Please refer to bootswatch for more information.","title":"2. Install mkdocs-bootswatch"},{"location":"misc/doc-guide/#3-install-a-markdown-editor","text":"You can simply edit the markdown (.md) files by any text editor, but it's better to user a professional markdown editor. typora . It supports all of the platforms (Windows/MacOS/Linux). Please configure typora to strict Markdown mode. That ensures you get the same output effects on both typora and mkdocs . vscode . It's also a good editor and has abundant functions and extensions. You can install extensions of Markdown, Preview and Spell checker.","title":"3. Install a markdown editor"},{"location":"misc/doc-guide/#4-install-other-optional-tools","text":"pdf2svg: This tool can convert a pdf lossless picture to svg format. For Mac OS, it can be easily installed by Homebrew , simply by brew install pdf2svg . Alternative choice is Inkscape which is a free drawing tool and can help you draw and convert vector graphics.","title":"4. Install other optional tools"},{"location":"misc/doc-guide/#website-structure","text":"First, you need to git clone the omi-doc repository and go to web-doc directory. Make sure you are working on a branch other than master. $ git clone git@github.com:OpenCAPI/omi-doc.git $ cd omi-doc/web-doc Create a branch if needed: $ git branch <new-branch-name> $ git checkout <A branch other than master> The docs folder is where to put the markdown files, and the mkdocs.yml lists the website structure and global definitons. For example, this site has a structure like: nav: - Main Elements: - 'Overview': 'index.md' - 'FIRE Description': 'blocs/fire.md' - 'ICE Description': 'blocs/ice.md' - 'GEMINI Description': 'blocs/gemini.md' - 'FMC+ ENABLEMENT Description': 'blocs/enablement.md' - Misc: - 'Document Guide': 'misc/doc-guide.md' You can edit them as needed.","title":"Website Structure"},{"location":"misc/doc-guide/#write-markdown-pages","text":"On your local desktop, edit markdown files under web-doc/docs folder. If you want to add/delete/rename the files, you also need to edit mkdocs.yml Now it's time to work with an editor (i.e, typora) to write the documents. You also may need to learn some markdown syntax. Don't worry, that's easy. And please turn on the \"spell checking\" in your Markdown editor. In your terminal (MacOS or Linux), or cmd (Windows), start a serve process: # enter in the directory where mkdocs.yml is located cd ~/omi-doc/web-doc #launch a local webserver to test your mods mkdocs serve Then open a web browser, input http://127.0.0.1:8000 . So whenever you save any markdown files, you can check the generated website immediately.","title":"Write Markdown pages"},{"location":"misc/doc-guide/#play-with-pictures","text":"","title":"Play with pictures"},{"location":"misc/doc-guide/#the-first-rule","text":"Reduce the usage of pictures. Avoid unnecessary screenshots.","title":"The first rule"},{"location":"misc/doc-guide/#its-quite-easy","text":"You can insert jpg, png, svg files. You can also simply copy paste pictures from clipboard and paste them. Copy the files into a directory ./${filename}.assets , and here ${filename} is the name of markdown file. Use relative links in the document. Note If you are using Typora, please enable \"Copy images into ./${filename}.assets folder\" in Preferences of typora.","title":"It's quite easy"},{"location":"misc/doc-guide/#tools-to-draw-diagrams","text":"You can take any drawing tools to create diagrams. You can save them as PNG format, but the better way is to save to SVG format. For the diagrams from Microsoft PowerPoint, you can select the region of a diagram in PPT, Ctrl-C to copy it, and Ctrl-V to paste it in Typora directly. In this case, the diagram is saved as an PNG file. But there is a better way to get the smallest file size and best quality: In PowerPoint, select the region of diagram, right-click mouse -> \"Save as Picture ...\" and save it as \"PDF\" format. Open the PDF file with Inkscape . (Right-click the file -> \"Open with ...\", choose Inkscape in the poped up list). Unclick \"Embed images\" and then \"OK\". In Inkscape, save it as SVG file. Insert the SVG file into Typora. In my experiment, the PNG file is 188KB. But with the above flow to save it as SVG file, its size is 62KB. As a vectored diagram, it doesn't have any quality loss when zooming in. Warning Please use normal fonts in PPT, for example \"Arial\". Otherwise you may get a SVG file with a replaced font and that may look different.","title":"Tools to draw diagrams"},{"location":"misc/doc-guide/#code-blocks-and-admonitions","text":"","title":"Code blocks and Admonitions"},{"location":"misc/doc-guide/#code-blocks","text":"Please assign the code language so it can be correctly rendered. For example ``` C for C language. // A function to implement bubble sort void bubbleSort(int arr[], int n) { int i, j; for (i = 0; i < n-1; i++) // Last i elements are already in place for (j = 0; j < n-i-1; j++) if (arr[j] > arr[j+1]) swap(&arr[j], &arr[j+1]); }","title":"Code blocks"},{"location":"misc/doc-guide/#admonitions","text":"You can use !!! Note or !!! Warning or !!! Danger to start a paragraph of admonitions. Then use 4 spaces to start the admonition text. For example !!! Danger \"Error Message\" This is a dangerous error. It will be shown as: Error Message This is a dangerous error.","title":"Admonitions"},{"location":"misc/doc-guide/#deploy-to-github-pages","text":"When most of the edition work is done, and it's time to commit your documents to omi-doc github. First, you should commit and push your changes of source files (in web-doc ) to git repository. Create pull request, ask someone to review the documents, merge them into master branch after getting approvements. Then you can simply publish website with just one step: cd <PATH>/omi-doc/web-doc mkdocs gh-deploy The entire website will be pushed to gh-pages branch of omi-doc repository. The documentation website will be available at https://opencapi.github.io/omi-doc/ !","title":"Deploy to Github Pages"}]}