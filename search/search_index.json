{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OMI Overview OMI , stands for Open Memory Interface. Check OMI web site at https://openmemoryinterface.org/open-projects/ OMI is a highly tuned bus that was developed for near memory and is easily migratable to emerging memory solutions (e.g., Storage Class Memory). This serial coherent bus, a subset of OpenCAPI (3.1 version), was architected specifically for the interface between a processor and Near Memory having absolute minimum latency with significant bandwidth and capacity. OMI is the solution to our evolving industry\u2019s demand for Near Memory as data centers evolve from compute centric to becoming data centric. Due to the smaller beachfront required by the OMI serial interface, processors using OMI are able to support many more memory channels. For example, IBM's Power10 is the first processor offering 1 Terabyte/s bandwidth on the memory side. The same bandwidth with external hardware is able to support up to 2 Petabytes of addressable memory. Thanks to the very low latency, this OMI near-memory connection brings plenty of new memory disaggregation possibilities. \"Memory inception\" for example, allows a process to borrow host memory from another server. \"Pool of memories\" can now be built to optimize the sharing of the most expensive resource of our servers. Using this CAPI/OpenCAPI technology associated with FPGAs has not only solved unbelievable bottlenecks, but has drastically decreased the power consumption of previous solutions. This Documentation site presents an overview of host and device chips as well as an enablement guide. Fire host design example Ice device design example Gemini device card design example OMI Enablement Guide All the code and related materials are contributed to different Github repositories. REFERENCE DOCUMENTS and GUIDES DDIMM PMICs information available in the JEDEC Standard Document JESD301-1A DDIMM EEPROM content \"JEDEC Publication No. 106BE : STANDARD MANUFACTURER\u2019S IDENTIFICATION CODE\" JEP106BE.pdf FMC+ OMI ENABLEMENT GUIDE https://github.com/OpenCAPI/omi_enablement/ contains an example of host on a FMC+ board to evaluate DDMIMs modules HOST SIDE FPGA REFERENCE DESIGN https://github.com/OpenCAPI/omi_host_fire contains a host FPGA reference design DEVICE SIDE FPGA REFERENCE DESIGN https://github.com/OpenCAPI/omi_device_ice contains a device FPGA reference design DEVICE SIDE ASIC REFERENCE DESIGN https://github.com/OpenCAPI/omi_asic_device_reference_design contains an ASIC device reference design","title":"Overview"},{"location":"#omi-overview","text":"OMI , stands for Open Memory Interface. Check OMI web site at https://openmemoryinterface.org/open-projects/ OMI is a highly tuned bus that was developed for near memory and is easily migratable to emerging memory solutions (e.g., Storage Class Memory). This serial coherent bus, a subset of OpenCAPI (3.1 version), was architected specifically for the interface between a processor and Near Memory having absolute minimum latency with significant bandwidth and capacity. OMI is the solution to our evolving industry\u2019s demand for Near Memory as data centers evolve from compute centric to becoming data centric. Due to the smaller beachfront required by the OMI serial interface, processors using OMI are able to support many more memory channels. For example, IBM's Power10 is the first processor offering 1 Terabyte/s bandwidth on the memory side. The same bandwidth with external hardware is able to support up to 2 Petabytes of addressable memory. Thanks to the very low latency, this OMI near-memory connection brings plenty of new memory disaggregation possibilities. \"Memory inception\" for example, allows a process to borrow host memory from another server. \"Pool of memories\" can now be built to optimize the sharing of the most expensive resource of our servers. Using this CAPI/OpenCAPI technology associated with FPGAs has not only solved unbelievable bottlenecks, but has drastically decreased the power consumption of previous solutions. This Documentation site presents an overview of host and device chips as well as an enablement guide. Fire host design example Ice device design example Gemini device card design example OMI Enablement Guide All the code and related materials are contributed to different Github repositories.","title":"OMI Overview"},{"location":"#reference-documents-and-guides","text":"DDIMM PMICs information available in the JEDEC Standard Document JESD301-1A DDIMM EEPROM content \"JEDEC Publication No. 106BE : STANDARD MANUFACTURER\u2019S IDENTIFICATION CODE\" JEP106BE.pdf","title":"REFERENCE DOCUMENTS and GUIDES"},{"location":"#fmc-omi-enablement-guide","text":"https://github.com/OpenCAPI/omi_enablement/ contains an example of host on a FMC+ board to evaluate DDMIMs modules","title":"FMC+ OMI ENABLEMENT GUIDE"},{"location":"#host-side-fpga-reference-design","text":"https://github.com/OpenCAPI/omi_host_fire contains a host FPGA reference design","title":"HOST SIDE FPGA REFERENCE DESIGN"},{"location":"#device-side-fpga-reference-design","text":"https://github.com/OpenCAPI/omi_device_ice contains a device FPGA reference design","title":"DEVICE SIDE FPGA REFERENCE DESIGN"},{"location":"#device-side-asic-reference-design","text":"https://github.com/OpenCAPI/omi_asic_device_reference_design contains an ASIC device reference design","title":"DEVICE SIDE ASIC REFERENCE DESIGN"},{"location":"blocs/apollo/","text":"Apollo Description Description This \"Apollo\" card was developed for use in doing post-silicon validation of OMI memory buffers as well as various DDIMM provider without the need for having an actual processor piece of silicon to drive the OMI traffic. The \"Apollo\" card hosts an FPGA containing \"FIRE\" OMI host side FPGA reference design .","title":"APOLLO Card (Host) Description"},{"location":"blocs/apollo/#apollo-description","text":"","title":"Apollo Description"},{"location":"blocs/apollo/#description","text":"This \"Apollo\" card was developed for use in doing post-silicon validation of OMI memory buffers as well as various DDIMM provider without the need for having an actual processor piece of silicon to drive the OMI traffic. The \"Apollo\" card hosts an FPGA containing \"FIRE\" OMI host side FPGA reference design .","title":"Description"},{"location":"blocs/c_code/","text":"C Enablement Software Description Architecture Details OMI enablement platform requires software to configure/synchronize/exercise the host and the DDIMMs modules. Initial development was performed using IBM's Cronus tool and can still be used if required. To ease the discovery of OMI technology, a simple C code has been developed. It can be run either on a external Raspberry pi, or any computer providing an I2C acces to the VCU128 card or on an internal Microblaze microprocessor (under development) Requirements \"smbus2\" librairies are required. General knowledge of C configuration on chosen hardware/OS as well as I2C skills are required. Source code is available here Compilation For example on a raspberry pi : gcc *.c -o omirpi.out General Preparation and Settings ./omirpi.out --help For a verbose display of any command, add the --log option just after omi.py ./omirpi.out --log yourcommand With any command, the I2C bus must be provided with -b option. If you are using a different I2C bus number, the number should be passed like this: ./omirpi.out anycommand -b 3 You can scan the I2C bus with the command: ./omirpi.out scan -b 3 Warning ! Code is provided as is, if unexpected I2C lanes hangs occur, a complete reset of Fire might be required Adapter card Mux settings To be able to access a ddimm from I2C, muxes need to be configured: ./omirpi.out initpath -d ddimm # ddimm : I2C selected DDIMM . Can be a,b,none. ./omirpi.out initpath -d a ./omirpi.out initpath -d b ./omirpi.out initpath -d none At any time, you can check the current path already set up with: ./omirpi.out checkpath Initialize device Before using the following functions, use the following command to initialize the host, without it, i2c errors will be encountered: ./omirpi.out init Host/device information To print out information about a chip, just do: ./omirpi.out info -c chip # chip: host/device name. Can be either \"fire\" or \"explorer\" (or \"ice\") ./omirpi.out info -c fire ./omirpi.out info -c explorer ./omirpi.out info -c ice Reseting Device Change reset state of a DDIMM or multiple DDIMMs from fire: ./omirpi.out ddimmreset -d ddimms -s newresetstate ddimms: letters of ddimms selected (Examples: abcdsw, ab, a) newresetstate: on to activate reset mode, off to quit reset mode Example ./omirpi.out ddimmreset -d ab -s on Read a host/device register: ./omirpi.out read -c chip -r regaddr chip: chip name. Can be either fire or explorer (or ice) regaddr: register address given in hex ./omirpi.out read -c fire -r 0x100000000000004 ./omirpi.out read -c explorer -r 0x20b080 ./omirpi.out read -c explorer -r 0x8012811 Write to a host/device register: ./omirpi.out write -c chip -r regaddr -d data chip: chip name. Can be either fire or explorer (or ice) regaddr: register address given in hex data: new value to write to the register, in hex ./omirpi.out write -c fire -r 0x100000000000004 -d 0x3f ./omirpi.out write -c explorer -r 0x8012811 -d 0x5000000006f Trigger training/synchronisation procedure: ./omirpi.out sync -d ddimms ddimms: letters of ddimms to sync (Examples: ab, b, a) !! This function commutes the muxes automatically to sync the ddims provided. !! Make sure to wait for about 20s after powering/resetting devices before launchig this command, !! otherwise it fails and needs to be re-executed. ./omirpi.out sync -d a ./omirpi.out sync -d b ./omirpi.out sync -d ab To check DDIMM training state: python3 omi.py checksync -d ddimms ddimms: letters of ddimms to sync check (Examples: ab, b, a) python3 omi.py checksync -d a python3 omi.py checksync -d b python3 omi.py checksync -d ab","title":"C Enablement Software Description"},{"location":"blocs/c_code/#c-enablement-software-description","text":"","title":"C Enablement Software Description"},{"location":"blocs/c_code/#architecture-details","text":"OMI enablement platform requires software to configure/synchronize/exercise the host and the DDIMMs modules. Initial development was performed using IBM's Cronus tool and can still be used if required. To ease the discovery of OMI technology, a simple C code has been developed. It can be run either on a external Raspberry pi, or any computer providing an I2C acces to the VCU128 card or on an internal Microblaze microprocessor (under development)","title":"Architecture Details"},{"location":"blocs/c_code/#requirements","text":"\"smbus2\" librairies are required. General knowledge of C configuration on chosen hardware/OS as well as I2C skills are required. Source code is available here","title":"Requirements"},{"location":"blocs/c_code/#compilation","text":"For example on a raspberry pi : gcc *.c -o omirpi.out","title":"Compilation"},{"location":"blocs/c_code/#general-preparation-and-settings","text":"./omirpi.out --help For a verbose display of any command, add the --log option just after omi.py ./omirpi.out --log yourcommand With any command, the I2C bus must be provided with -b option. If you are using a different I2C bus number, the number should be passed like this: ./omirpi.out anycommand -b 3 You can scan the I2C bus with the command: ./omirpi.out scan -b 3 Warning ! Code is provided as is, if unexpected I2C lanes hangs occur, a complete reset of Fire might be required","title":"General Preparation and Settings"},{"location":"blocs/c_code/#adapter-card-mux-settings","text":"To be able to access a ddimm from I2C, muxes need to be configured: ./omirpi.out initpath -d ddimm # ddimm : I2C selected DDIMM . Can be a,b,none. ./omirpi.out initpath -d a ./omirpi.out initpath -d b ./omirpi.out initpath -d none At any time, you can check the current path already set up with: ./omirpi.out checkpath","title":"Adapter card Mux settings"},{"location":"blocs/c_code/#initialize-device","text":"Before using the following functions, use the following command to initialize the host, without it, i2c errors will be encountered: ./omirpi.out init","title":"Initialize device"},{"location":"blocs/c_code/#hostdevice-information","text":"To print out information about a chip, just do: ./omirpi.out info -c chip # chip: host/device name. Can be either \"fire\" or \"explorer\" (or \"ice\") ./omirpi.out info -c fire ./omirpi.out info -c explorer ./omirpi.out info -c ice","title":"Host/device information"},{"location":"blocs/c_code/#reseting-device","text":"","title":"Reseting Device"},{"location":"blocs/c_code/#change-reset-state-of-a-ddimm-or-multiple-ddimms-from-fire","text":"./omirpi.out ddimmreset -d ddimms -s newresetstate ddimms: letters of ddimms selected (Examples: abcdsw, ab, a) newresetstate: on to activate reset mode, off to quit reset mode","title":"Change reset state of a DDIMM or multiple DDIMMs from fire:"},{"location":"blocs/c_code/#example","text":"./omirpi.out ddimmreset -d ab -s on","title":"Example"},{"location":"blocs/c_code/#read-a-hostdevice-register","text":"./omirpi.out read -c chip -r regaddr chip: chip name. Can be either fire or explorer (or ice) regaddr: register address given in hex ./omirpi.out read -c fire -r 0x100000000000004 ./omirpi.out read -c explorer -r 0x20b080 ./omirpi.out read -c explorer -r 0x8012811","title":"Read a host/device register:"},{"location":"blocs/c_code/#write-to-a-hostdevice-register","text":"./omirpi.out write -c chip -r regaddr -d data chip: chip name. Can be either fire or explorer (or ice) regaddr: register address given in hex data: new value to write to the register, in hex ./omirpi.out write -c fire -r 0x100000000000004 -d 0x3f ./omirpi.out write -c explorer -r 0x8012811 -d 0x5000000006f","title":"Write to a host/device register:"},{"location":"blocs/c_code/#trigger-trainingsynchronisation-procedure","text":"./omirpi.out sync -d ddimms ddimms: letters of ddimms to sync (Examples: ab, b, a) !! This function commutes the muxes automatically to sync the ddims provided. !! Make sure to wait for about 20s after powering/resetting devices before launchig this command, !! otherwise it fails and needs to be re-executed. ./omirpi.out sync -d a ./omirpi.out sync -d b ./omirpi.out sync -d ab","title":"Trigger training/synchronisation procedure:"},{"location":"blocs/c_code/#to-check-ddimm-training-state","text":"python3 omi.py checksync -d ddimms ddimms: letters of ddimms to sync check (Examples: ab, b, a) python3 omi.py checksync -d a python3 omi.py checksync -d b python3 omi.py checksync -d ab","title":"To check DDIMM training state:"},{"location":"blocs/enablement/","text":"OMI ENABLEMENT Guide INTRODUCTION This guide will cover the steps to evaluate OMI using FIRE and EXPLORER designs. First thing is to setup hardware and software environments. Eventually go into some detials of the registers and memory space accesses. Finally use the system to get familiar with the OMI technology SETUP This enablement setup page will presents hardware and software examples to allow proper evaluation of OMI. This step should allow you to read FIRE's ID register: It contains the git revision of the hardware build and few other information: python3 omi.py read -c fire -r 0x100000000000000 Rd Fire Addr 0x100000000000000 : 0x000000003e29c7d2 (This an example of git level) OMI synchronisation Once FIRE is accessible and DDIM are powered up, we need to synchroize the OMI links. After power supplies set to ON and FIRE being reset cycled. This is simply achieved with the following python commands: python3 omi.py initpath -d a; python3 omi.py init; python3 omi.py sync -d a python3 omi.py initpath -d b; python3 omi.py init; python3 omi.py sync -d b OMI CONFIGURATION AND TESTS Once OMI links are set the latest step consists in configuring the Explorer to provide access to its local DDIMM memory. python3 omi.py ddimmcfg -d a Once this is done, FBIST and C3S tests can be run. FBIST TESTS ... working on it ... C3S TESTS ... working on it ...","title":"FMC+ ENABLEMENT Description"},{"location":"blocs/enablement/#omi-enablement-guide","text":"","title":"OMI ENABLEMENT Guide"},{"location":"blocs/enablement/#introduction","text":"This guide will cover the steps to evaluate OMI using FIRE and EXPLORER designs. First thing is to setup hardware and software environments. Eventually go into some detials of the registers and memory space accesses. Finally use the system to get familiar with the OMI technology","title":"INTRODUCTION"},{"location":"blocs/enablement/#setup","text":"This enablement setup page will presents hardware and software examples to allow proper evaluation of OMI. This step should allow you to read FIRE's ID register: It contains the git revision of the hardware build and few other information: python3 omi.py read -c fire -r 0x100000000000000 Rd Fire Addr 0x100000000000000 : 0x000000003e29c7d2 (This an example of git level)","title":"SETUP"},{"location":"blocs/enablement/#omi-synchronisation","text":"Once FIRE is accessible and DDIM are powered up, we need to synchroize the OMI links. After power supplies set to ON and FIRE being reset cycled. This is simply achieved with the following python commands: python3 omi.py initpath -d a; python3 omi.py init; python3 omi.py sync -d a python3 omi.py initpath -d b; python3 omi.py init; python3 omi.py sync -d b","title":"OMI synchronisation"},{"location":"blocs/enablement/#omi-configuration-and-tests","text":"Once OMI links are set the latest step consists in configuring the Explorer to provide access to its local DDIMM memory. python3 omi.py ddimmcfg -d a Once this is done, FBIST and C3S tests can be run.","title":"OMI CONFIGURATION AND TESTS"},{"location":"blocs/enablement/#fbist-tests","text":"... working on it ...","title":"FBIST TESTS"},{"location":"blocs/enablement/#c3s-tests","text":"... working on it ...","title":"C3S TESTS"},{"location":"blocs/enablement2/","text":"OMI ENABLEMENT Guide HARDWARE DESCRIPTION For the purpose of open sourcing the design, a collaboration between OMI members led to a tuning of an OMIhost FPGA reference design \" Fire \" to be used in a VCU128 Card from AMD/Xilinx. With addition of a simple FMC+ connected add-on card, any OMI compatible memory DDIMM module can be evaluated. The setup allows evaluation of 2 DDIMMs modules in slots A and B. Some code is required to synchronize and test the OMI DDIMMs. Enablement example codes have been developed in Python and in C. Same functions are available. Either the code is executed in a companion raspberry pi or any I2C capable computer, or even in an embedded microblaze processor (in the latter case use the C version as it executes much faster) Python source code is available at : Python Code Python code documentation is available at : Python Documentation C source code is available at : C Code C code documentation is available at : C Documentation Enablement example code Checks I2C tree Synchronizes DDIMMs Executes simple transfers in memory (not published yet) Note: The Raspberry pi can host an Cronus server, should you want to evaluate OMI in a Cronus environment. REQUIREMENTS Requirements depends on what kind of experiments need to be conducted. Cronus with a raspberry pi hosting a Cronus server and dealing with I2C accesses (out of present scope) Standalone Python or C code running on Raspberry Pi or a PC with I2C capabilities Embedded PetaLinux with Microblaze next to Fire in the FPGA requires TFTP / NFS / DNS server to host boot and file system can run C standalone code (Python is too slow to execute in a timely manner) Standalone C code running on a no-OS Microblaze embedded processor (not developed yet) only requires a serial terminal (can be \"picocom\" using UART through programming USB cable) Minimum Hardware requirements : Procure the following: A VCU128 Board from AMD/Xilinx and a JTAG controlling PC (can be the Raspberry pi) An adapter board from Tormem . as of today only V1 is available Version 1 allows basic DDIMM interface Version 2 will also allow FIRE reset and power control of 12V, 3.3V and 1.8V. At least one DDIMM module A USB relay card to ensure automated fire reset / 3.3V / 12V POWER control (if using an adapter board version 1) Software requirements : Obtain an AMD/Xilinx Licence for Vivado. Requires 2018.3 version for this contribution (best timing results at maximum bandwidth). ENABLEMENT STEPS with an external I2C master git clone the \" vcu128_enablement \" branch of Fire design. First synthetize, implement and generate bitstream of \"FIRE\" design for the VCU128 using the specific branch as specified in the README.md file. git clone the https://github.com/OpenCAPI/omi_enablement/ and use /python or /c directory with a debugging raspberry pi or any computer with I2C capability to check you can see the design. Choose Python or C control, both will send requests through the I2C bus to the Fire design. Explorer chip are usually access through In band commands are dealt by Fire. ENABLEMENT STEPS with internal Microblaze as I2C master When using Tormem adapter board version 1, I2C control by Microblaze requires a hacking of the VCU128 board as there is no provision to connect an external cable. git clone the \" vcu128_enablement \" branch of Fire design. First synthetize, implement and generate bitstream of \"FIRE\" design for the VCU128 using the specific branch as specified in the README.md file. To prepare the integration of FIRE and microblaze structure, generate an IP of Fire design. Git clone the \" omi_enablement \" to get the necessary material to build a {Fire + Microblaze} structure. Hardware: Option 1 : re-create your own design {FIRE + Microblaze} From the \"hw/\" directory, use hw_script.sh and tcl_code.tcl to generate a microblaze environment. you'll be ask to provide the FIRE ip path from step 3. you'll get the .xsa file which is the only file required for the remaining steps. It contains a complete description of the hardware. Hardware Option 2: use pre-built hardware system.bit. Install petalinux (we used the 2021.1 version) Software Option 1: create your petalinux environment using petalinux-create, create a vcuomi project directory. petalinux-create --type project --template microblaze --name vcuomi remaining tasks: To Be described ... Software Option 2: Use pre_built linux Use https://github.com/OpenCAPI/omi_enablement/tree/main/petalinux content run the script.sh and then wsl@wsl:~/omi_enablement/petalinux$ petalinux-create --type project -s *.bsp wsl@wsl:~/omi_enablement/petalinux$ mkdir vcuomi/images && mkdir vcuomi/images/linux wsl@wsl:~/omi_enablement/petalinux$ cp -r linux/images/* vcuomi/images/linux/. copy the images/linux content to your tftp directory of the remote computer acting as a server. From the remote tftp/NFS server: copy the tftp/rootfs.tar.gz directory to your NFS directory. Adjust permissions accordingly. From petalinux installation dir use xsct -nolrwrap to load the system.bit into the fpga. open a picocom or any RS232 terminal on the FPGA RS232 link. trigger a boot of the microblaze with petalinux-boot. I2C architecture foreword I2C is either used in a traditional manner, ie Master issues a R or W to a I2C chip adress. The addressed chip also provides an internal register address. That's the case for EEPROM, PMIC (Power Managment IC), I2C muxes etc .. As far as FIRE and EXPLORER are concerned, they are accessed using different modes depending on which register is concerned. Internal registers are accessed through an indirect mecanism, and inband is possible for devices, hence this documentation. I2C tree I2C components Master: Raspberry pi or any I2C capable computer Host component from Apollo or VCU128 board containing a FPGA with a FIRE host design at @0x38 For each DDIMM : DDIMM EEPROM containing VPD data at I2C@0x50 PMIC1 and PMIC2 (Power Management Integrated Circuits) setting the Power supplied of the board at @0x4F and @0x67 OMI DDIMM OCMB (OpenCAPI Memory Buffer also called Explorer) at @0x20 Reset and power supply control DDIMM Exporer reset signal is controlled through an FMC+ connector lane and a FIRE FML register, while FIRE reset is required with an external logic. This logic can be easyly performed with a set of USB controlled electromechanical relays hooked up to the controlling computer. The same relay board an control power supplies through the adapter power supply connector. Each development lab need to tune this signals to allow resetting FIRE and switch on and off power supplies at any time. Specific DDIMM I2C path Tormem adapter board can have up to 2 devices. Each of them can be accessed through I2C using a multiplexer switch. After a power on and Fire reset: Select the proper DDIMM I2C path (set the adapter mux accordingly) ~/vcu128_ctl_sh/i2c_reset.sh ; python3 omi.py initpath -d a To check with mux is selected, use the following command: python3 omi.py checkpath` Once Path is set, the init routine will power on the 2 DDIMM PMICS. No DDIMM selection, as it will power on the currently selected DDIMM. python3 omi.py init Once I2C path is set and DDIM is powered on, we can list the viewable devices using Adapter version 1: Typically, you will identify the FIRE host as @0x38, the OMI DDIMM device as @0x20, the EEPROM as @0x50, the 2 PMIC as @0x4F and 0x67 and the different muxes at @0x71 and 0x73 from the Adapter board. FIRE I2C is a slave component set with 0x38 as I2C address. This FIRE I2C provides access to all address mapping from the host side as well as from the device sides. After a reset of the Xilinx AXI-IIC IP initialization of the IP is preformed as follow: Soft reset (SOFTR @040) Slave Mode Select (CR @100) Enable AIX IIC controller (CR @100) Set I2C slave address to 0x38 (ADDR @110) Set an irq if fifo is full (16 locations filled) (RX_FIFO_PIRQ @120) The I2C protocol is not used as the typical one, meaning that any I2C access (either \u201cread\u201d or \u201cwrite\u201d) fills the I2C Rx FIFO with almost 1 word. The state machine associated to this I2C IP (i2c_ctrl_mac) is polling indefinitely the I2C IP (axi_iic). As soon as it detects that the Rx FIFO is not empty then 8x8bits words are read (even if only 1 byte was written). Afterwards if the FIFO is empty, it means that the access is a \u201cread\u201d, otherwise the logic will read another 8x8bits words while considering the operation as a \u201cwrite\u201d. To summarize: 8x I2C 8bits-words received corresponds to a FIRE register address to read. 16x I2C 8bits-words received corresponds to the FIRE register address and the data to write Read or write of 1 word will generate a \u201cdecode1c\u201d response (generated by the AXI bridges) written to the I2C FIFO As soon as a word is written in the I2C IP at @0x38, then \u201ci2c_ctrl_mac\u201d picks the data as an address and accesses the appropriate component. If required access is a \u201cread\u201d, then the data collected from the component is written to the axi_iix TX fifo. If the required access is a \u201cwrite\u201d, then the data is read by the \u201ci2c_ctrl_mac\u201d and sent to the appropriate component. Host / FIRE memory mapping and Access a. Memory mapping The host offers 2 types of accesses. First of them deals with its own internal registers. Most used among them are: FML (FIRE Miscellaneous Library) containing mainly the Fire version and the reset of the devices C3S (OpenCAPI Command and Configure Sequencer) used to manually create an OMI frame (called flit) FBIST (Function Built-In Self Test) used to automatically generate and check high bandwidth traffic on the OMI links. The host can also access all memory mapping of the DDIMM devices (up to 4 devices) Table 1: FIRE memory space Example of FIRE internal register i. Read FIRE_VERSION at @0x00 of FML register python3 omi.py read -c fire -r 0x100000000000000 Rd Fire Addr 0x100000000000000 : 0x000000003e29c7d2 This register contains [31:29]: \u2018001\u2019: frequency used for the internal clock of the FPGA which determines the OMI link frequency [ 1= 21.33 GBPS, 2 =23.46 GBPS, 3=25.6 GBPS] [28]: \u20181\u2019: dirty bit is used when the current image contains change not committed to the git version control [27:0]: \u201829c7d2\u2019 is the git level of the code ii. Reset/unreset the DDIMM0 device Reseting the DDIMMs is performed by the host. python3 omi.py read -c fire -r 0x100000000000004 Rd Fire Addr 0x100000000000004 : 0x000000000000003f Reset the DDIMM0 (bit3) python3 omi.py write -c fire -r 0x100000000000004 -d 000000037 Wr Fire Addr 0x100000000000004 : 0x0000000000000037 Writing check : Success python3 omi.py write -c fire -r 0x100000000000004 -d 000000037 Wr Fire Addr 0x100000000000004 : 0x000000000000003f Writing check : Success iii. Bad address access As soon as a bad i2C address is accessed, you may encounter one of the 2 different types of answer (with different severity): The answer \u201cdec0de1c\u201d will be sent by AMD/Xilinx axi crossbar as an answer to an unknown address (out of range) python3 omi.py read -c fire -r 0x1000F0000000004 Rd Fire Addr 0x1000f0000000004 : 0x00000000dec0de1c The answer \u201cdec0deff\u201d will be sent as an answer to address that is not modulo 4. ~/python/v6 $ python3 omi.py read -c fire -r 0x100000000000000 Rd Fire Addr 0x100000000000000 : 0x00000000335b5587 ~/python/v6 $ python3 omi.py read -c fire -r 0x100000000000001 Rd Fire Addr 0x100000000000001 : 0x00000000dec0deff ~/python/v6 $ python3 omi.py read -c fire -r 0x100000000000002 Rd Fire Addr 0x100000000000002 : 0x00000000dec0deff ~/python/v6 $ python3 omi.py read -c fire -r 0x100000000000003 Rd Fire Addr 0x100000000000003 : 0x00000000dec0deff ~/python/v6 $ python3 omi.py read -c fire -r 0x100000000000004 Rd Fire Addr 0x100000000000004 : 0x000000000000003f In the event you have modified the hdl design and not properly taken care of a memory range, an I2C error will be raised, and a reset of the fire chip will be needed if you access a bad address in an unallowed range! python3 omi.py read -c fire -r 0xin range but not answering address OSError: [Errno 5] Input/output error When this occurs a reset of the chip is required. OMI DDIMM OCMB memory mapping and access Contact Microchip support to obtain detailed information on firmware a. Memory mapping An EXPLORER register can be accessed in two ways: Directly through I2C. The user will need to select the port of the DDIMM to switch the I2C path to the EXPLORER he wants to access Indirectly through FIRE. The OMI links between FIRE and EXPLORER need to be trained to use the \u201cin-band\u201d access. To select the EXPLORER he wants to access, the user will use a specific address depending on the port number. Each EXPLORER register can be accessed through different addresses. The reference used is the Microchip \"Explorer_registers_Mips_view.pdf\" document. The 0x808xxxx registers are ordered by pair but can be accessed alone or by pair. As an example, let\u2019s access the register 0x8084168: OCMB - MB_SIM_MMIO_OTRCFG76_LEFT and 0x808416C: OCMB - MB_SIM_MMIO_OTRCFG76_RIGHT. They can be accessed either by their \u00ab register address \u00bb, by their \u00ab SCOM address \u00bb, by their \u00ab MMIO address \u00bb or by their \u00ab FIRE adress \u00bb: Register Address : @0x08084168 and @0x0808416C (32 bits access) I2C Register Address : @0xA8084168 and @0xA808416C (32 bits access) SCOM Address: Reg@0x8084168/C >> 3 => SCOM@ 0x801082D (64 bits access) MMIO Address: Reg@8084168/C => MMIO@ @0026C/8 (32 bits access) FIRE Address: => 0x3001000140084168 (64 bits access) To access different slots through FIRE, use the appropriate offset: DDIM_0_CFG / Port A: 0x3001_0001_4008_4168 DDIM_1_CFG / Port B: 0x3001_0401_4008_4168 b. Registers access i. I2C access (at any time and directly in explorer chip) tututututttuDDIMM / Port is selected by the I2C switch on the Tormem adapter board python3 omi.py initpath -d a #(done once to select the right OMI DDIMM / Port) MB_SIM_MMIO_OTRCFG76_LEFT + MB_SIM_MMIO_OTRCFG76_RIGHT 64 bits Read SCOM@ @801082D => 0x0000000f_00000000 python3 omi.py read -c exp -r 0801082D => 0x0000000f00000000 64 bits Write SCOM@ @801082D => 0x000000ff_00000000 python3 omi.py write -c exp -r 0801082D -d 0x0000ff00000000 MB_SIM_MMIO_OTRCFG76_LEFT => Reg @0x8084168 I2C Reg @0xA8084168 = SCOM @0801082D 32 bits Read Reg@ @0x8084168 => 0000000F python3 omi.py readreg -c exp -r 0x8084168 =>0x0000000F 32 bits Write Reg@ @0x8084168 => 000000FF (always start by lower address pair and then upper address pair) python3 omi.py writereg -c exp -r 0x8084168 -d 0x000000FF MB_SIM_MMIO_OTRCFG76_RIGHT => Reg @0x808416C = I2C Reg @0xA808416C = SCOM @0801082D 32 bits Read Reg@ @0x808416C => 00000000 python3 omi.py readreg -c exp -r 0x808416C => 0x00000000 32 bits Write Reg@ @0x808416C => 000000AA (always start by lower address pair and then upper address pair) python3 omi.py writereg -c exp -r 0x808416C -d 0x000000AA ii. In-Band access using the FIRE DDIMM_0 MMIO register address (access is done through FIRE only after OMI Links are trained) DDIMM / Port is selected by the address used DDIM_0_MMIO / Port A: 0x3001_0001_4008_4168 DDIM_1_MMIO / Port B: 0x3001_0401_4008_4168 MB_SIM_MMIO_O0MBIT_O0DID_LEFT + MB_SIM_MMIO_O0MBIT_O0DID_RIGHT 64 bits Read Reg@ @08084168 => 0x00000f_00000000 64 bits Write Reg@ @08084168 => 0x0000ff_00000000 python3 omi.py read -c fire -r 0x3001000140084168 => 0x0000000f00000000 64 bits Write Reg@ @08084168 => 0x0000ff_00000000 MB_SIM_MMIO_OTRCFG76_LEFT => MMIO @0026C = Reg @0x8084168 = SCOM @0801082D 32 bits Read MMIO@ @0026C => 0000000F 32 bits Write MMIO@ @0026C => 000000FF python3 omi.py read -c fire -r 0x200100000000026c => 0x000000000000000f 32 bits Write MMIO@ @0026C => 000000FF python3 omi.py write -c fire -r 0x3001000140084168 -d 0x000000ff00000000 MB_SIM_MMIO_OTRCFG76_LEFT => MMIO @0026C = Reg @0x8084168 = SCOM @0801082D 32 bits Read MMIO@ @0026C => 0000000F python3 omi.py read -c fire -r 0x200100000000026c => 0x000000000000000f 32 bits Write MMIO@ @0026C => 000000FF MB_SIM_MMIO_OTRCFG76_RIGHT => MMIO @00268 = Reg @0x808416C = SCOM @0801082D 32 bits Read MMIO@ @00268 => 00000000 python3 omi.py write -c fire -r 0x200100000000026c -d 0x000000ff MB_SIM_MMIO_OTRCFG76_RIGHT => MMIO @00268 = Reg @0x808416C = SCOM @0801082D 32 bits Read MMIO@ @00268 => 00000000 32 bits Write MMIO@ @00268 => 00000000 python3 omi.py read -c fire -r 0x2001000000000268 => 0x0000000000000000 32 bits Write MMIO@ @00268 => 00000000 Notice the address swap with 32 bits access! MMIO @0026C => Reg @0x8084168 python3 omi.py write -c fire -r 0x2001000000000268 -d 0x00000000 Notice the address swap with 32 bits access! MMIO @0026C => Reg @0x8084168 iii. In-Band access using C3S to manually build a Flit (access is done through Fire only after OMI Links are trained) Pre-requisite => Only allow template 0 32 bits Read MMIO@ @0026C => FADAFAAB Control array => C3S RESP WRITE ADDR RESET python3 omi.py read -c fire -r 0x2001000000000224 => 0x00000221 python3 omi.py write -c fire -r 0x2001000000000224 -d 0x00000001 32 bits Read MMIO@ @0026C => FADAFAAB Control array => C3S RESP WRITE ADDR RESET Data array python3 omi.py write -c fire -r 0x0101000000030004 -d 0x0000000000000200 Data array Flow Array python3 omi.py write -c fire -r 0x010100000000000E -d 0x0000000000000000 python3 omi.py write -c fire -r 0x0101000000000006 -d 0x0000000040000000 python3 omi.py write -c fire -r 0x0101000000000005 -d 0x0000000000000000 python3 omi.py write -c fire -r 0x0101000000000004 -d 0x000000000026C000 python3 omi.py write -c fire -r 0x0101000000000003 -d 0x0000000000E00000 Flow Array Control Array python3 omi.py write -c fire -r 0x0101000000020000 -d 0x0000000080000001 python3 omi.py write -c fire -r 0x0101000000020100 -d 0x0000000000000100 Control Array Response Array to access 0x26C~64/4=B, read 1020B python3 omi.py read -c fire -r 0x0101000000030000 => 0x0000000000000008 python3 omi.py write -c fire -r 0x0101000000030000 -d 0x0000000000000009 python3 omi.py read -c fire -r 0x0101000000030000 => 0x0000000000000008 python3 omi.py read -c fire -r 0x0101000000030000 => 0x0000000000000008 python3 omi.py write -c fire -r 0x0101000000030000 -d 0x000000000000000A Response Array to access 0x26C~64/4=B, read 1020B 32 bits Write MMIO@ @0026C => ABCDEFAA python3 omi.py read -c fire -r 0x010100000001020B => 0x00000000FADAFAAB 32 bits Write MMIO@ @0026C => ABCDEFAA Flow Array Data Array python3 omi.py write -c fire -r 0x010100000000000E -d 0x0000000000000001 python3 omi.py write -c fire -r 0x0101000000000006 -d 0x0000000040000000 python3 omi.py write -c fire -r 0x0101000000000005 -d 0x0000000000000000 python3 omi.py write -c fire -r 0x0101000000000004 -d 0x000000000026C000 python3 omi.py write -c fire -r 0x0101000000000003 -d 0x0000000000E10000 Flow Array Control Array python3 omi.py write -c fire -r 0x0101000000020000 -d 0x0000000080000001 python3 omi.py write -c fire -r 0x010100000000010B -d 0x00000000ABCDEFAA python3 omi.py write -c fire -r 0x0101000000020100 -d 0x0000000080000002 python3 omi.py write -c fire -r 0x0101000000020200 -d 0x0000000080000003 python3 omi.py write -c fire -r 0x0101000000020300 -d 0x0000000000000100 Control Array Reassign default value for supported templates python3 omi.py write -c fire -r 0x2001000000000224 -d 0x00000221 python3 omi.py read -c fire -r 0x0101000000030000 => 0x0000000000000008 python3 omi.py write -c fire -r 0x0101000000030000 -d 0x0000000000000009 python3 omi.py read -c fire -r 0x0101000000030000 => 0x0000000000000008 python3 omi.py read -c fire -r 0x0101000000030000 => 0x0000000000000008 python3 omi.py write -c fire -r 0x0101000000030000 -d 0x000000000000000A Reassign default value for supported templates python3 omi.py write -c fire -r 0x2001000000000224 -d 0x00000221","title":"OMI ENABLEMENT Guide"},{"location":"blocs/enablement2/#omi-enablement-guide","text":"","title":"OMI ENABLEMENT Guide"},{"location":"blocs/enablement2/#hardware-description","text":"For the purpose of open sourcing the design, a collaboration between OMI members led to a tuning of an OMIhost FPGA reference design \" Fire \" to be used in a VCU128 Card from AMD/Xilinx. With addition of a simple FMC+ connected add-on card, any OMI compatible memory DDIMM module can be evaluated. The setup allows evaluation of 2 DDIMMs modules in slots A and B. Some code is required to synchronize and test the OMI DDIMMs. Enablement example codes have been developed in Python and in C. Same functions are available. Either the code is executed in a companion raspberry pi or any I2C capable computer, or even in an embedded microblaze processor (in the latter case use the C version as it executes much faster) Python source code is available at : Python Code Python code documentation is available at : Python Documentation C source code is available at : C Code C code documentation is available at : C Documentation Enablement example code Checks I2C tree Synchronizes DDIMMs Executes simple transfers in memory (not published yet) Note: The Raspberry pi can host an Cronus server, should you want to evaluate OMI in a Cronus environment.","title":"HARDWARE DESCRIPTION"},{"location":"blocs/enablement2/#requirements","text":"Requirements depends on what kind of experiments need to be conducted. Cronus with a raspberry pi hosting a Cronus server and dealing with I2C accesses (out of present scope) Standalone Python or C code running on Raspberry Pi or a PC with I2C capabilities Embedded PetaLinux with Microblaze next to Fire in the FPGA requires TFTP / NFS / DNS server to host boot and file system can run C standalone code (Python is too slow to execute in a timely manner) Standalone C code running on a no-OS Microblaze embedded processor (not developed yet) only requires a serial terminal (can be \"picocom\" using UART through programming USB cable) Minimum Hardware requirements : Procure the following: A VCU128 Board from AMD/Xilinx and a JTAG controlling PC (can be the Raspberry pi) An adapter board from Tormem . as of today only V1 is available Version 1 allows basic DDIMM interface Version 2 will also allow FIRE reset and power control of 12V, 3.3V and 1.8V. At least one DDIMM module A USB relay card to ensure automated fire reset / 3.3V / 12V POWER control (if using an adapter board version 1) Software requirements : Obtain an AMD/Xilinx Licence for Vivado. Requires 2018.3 version for this contribution (best timing results at maximum bandwidth).","title":"REQUIREMENTS"},{"location":"blocs/enablement2/#enablement-steps-with-an-external-i2c-master","text":"git clone the \" vcu128_enablement \" branch of Fire design. First synthetize, implement and generate bitstream of \"FIRE\" design for the VCU128 using the specific branch as specified in the README.md file. git clone the https://github.com/OpenCAPI/omi_enablement/ and use /python or /c directory with a debugging raspberry pi or any computer with I2C capability to check you can see the design. Choose Python or C control, both will send requests through the I2C bus to the Fire design. Explorer chip are usually access through In band commands are dealt by Fire.","title":"ENABLEMENT STEPS with an external I2C master"},{"location":"blocs/enablement2/#enablement-steps-with-internal-microblaze-as-i2c-master","text":"When using Tormem adapter board version 1, I2C control by Microblaze requires a hacking of the VCU128 board as there is no provision to connect an external cable. git clone the \" vcu128_enablement \" branch of Fire design. First synthetize, implement and generate bitstream of \"FIRE\" design for the VCU128 using the specific branch as specified in the README.md file. To prepare the integration of FIRE and microblaze structure, generate an IP of Fire design. Git clone the \" omi_enablement \" to get the necessary material to build a {Fire + Microblaze} structure. Hardware: Option 1 : re-create your own design {FIRE + Microblaze} From the \"hw/\" directory, use hw_script.sh and tcl_code.tcl to generate a microblaze environment. you'll be ask to provide the FIRE ip path from step 3. you'll get the .xsa file which is the only file required for the remaining steps. It contains a complete description of the hardware. Hardware Option 2: use pre-built hardware system.bit. Install petalinux (we used the 2021.1 version) Software Option 1: create your petalinux environment using petalinux-create, create a vcuomi project directory. petalinux-create --type project --template microblaze --name vcuomi remaining tasks: To Be described ... Software Option 2: Use pre_built linux Use https://github.com/OpenCAPI/omi_enablement/tree/main/petalinux content run the script.sh and then wsl@wsl:~/omi_enablement/petalinux$ petalinux-create --type project -s *.bsp wsl@wsl:~/omi_enablement/petalinux$ mkdir vcuomi/images && mkdir vcuomi/images/linux wsl@wsl:~/omi_enablement/petalinux$ cp -r linux/images/* vcuomi/images/linux/. copy the images/linux content to your tftp directory of the remote computer acting as a server. From the remote tftp/NFS server: copy the tftp/rootfs.tar.gz directory to your NFS directory. Adjust permissions accordingly. From petalinux installation dir use xsct -nolrwrap to load the system.bit into the fpga. open a picocom or any RS232 terminal on the FPGA RS232 link. trigger a boot of the microblaze with petalinux-boot.","title":"ENABLEMENT STEPS with internal Microblaze as I2C master"},{"location":"blocs/enablement2/#i2c-architecture-foreword","text":"I2C is either used in a traditional manner, ie Master issues a R or W to a I2C chip adress. The addressed chip also provides an internal register address. That's the case for EEPROM, PMIC (Power Managment IC), I2C muxes etc .. As far as FIRE and EXPLORER are concerned, they are accessed using different modes depending on which register is concerned. Internal registers are accessed through an indirect mecanism, and inband is possible for devices, hence this documentation.","title":"I2C architecture foreword"},{"location":"blocs/enablement2/#i2c-tree","text":"","title":"I2C tree"},{"location":"blocs/enablement2/#i2c-components","text":"Master: Raspberry pi or any I2C capable computer Host component from Apollo or VCU128 board containing a FPGA with a FIRE host design at @0x38 For each DDIMM : DDIMM EEPROM containing VPD data at I2C@0x50 PMIC1 and PMIC2 (Power Management Integrated Circuits) setting the Power supplied of the board at @0x4F and @0x67 OMI DDIMM OCMB (OpenCAPI Memory Buffer also called Explorer) at @0x20","title":"I2C components"},{"location":"blocs/enablement2/#reset-and-power-supply-control","text":"DDIMM Exporer reset signal is controlled through an FMC+ connector lane and a FIRE FML register, while FIRE reset is required with an external logic. This logic can be easyly performed with a set of USB controlled electromechanical relays hooked up to the controlling computer. The same relay board an control power supplies through the adapter power supply connector. Each development lab need to tune this signals to allow resetting FIRE and switch on and off power supplies at any time.","title":"Reset and power supply control"},{"location":"blocs/enablement2/#specific-ddimm-i2c-path","text":"Tormem adapter board can have up to 2 devices. Each of them can be accessed through I2C using a multiplexer switch. After a power on and Fire reset: Select the proper DDIMM I2C path (set the adapter mux accordingly) ~/vcu128_ctl_sh/i2c_reset.sh ; python3 omi.py initpath -d a To check with mux is selected, use the following command: python3 omi.py checkpath` Once Path is set, the init routine will power on the 2 DDIMM PMICS. No DDIMM selection, as it will power on the currently selected DDIMM. python3 omi.py init Once I2C path is set and DDIM is powered on, we can list the viewable devices using Adapter version 1: Typically, you will identify the FIRE host as @0x38, the OMI DDIMM device as @0x20, the EEPROM as @0x50, the 2 PMIC as @0x4F and 0x67 and the different muxes at @0x71 and 0x73 from the Adapter board. FIRE I2C is a slave component set with 0x38 as I2C address. This FIRE I2C provides access to all address mapping from the host side as well as from the device sides. After a reset of the Xilinx AXI-IIC IP initialization of the IP is preformed as follow: Soft reset (SOFTR @040) Slave Mode Select (CR @100) Enable AIX IIC controller (CR @100) Set I2C slave address to 0x38 (ADDR @110) Set an irq if fifo is full (16 locations filled) (RX_FIFO_PIRQ @120) The I2C protocol is not used as the typical one, meaning that any I2C access (either \u201cread\u201d or \u201cwrite\u201d) fills the I2C Rx FIFO with almost 1 word. The state machine associated to this I2C IP (i2c_ctrl_mac) is polling indefinitely the I2C IP (axi_iic). As soon as it detects that the Rx FIFO is not empty then 8x8bits words are read (even if only 1 byte was written). Afterwards if the FIFO is empty, it means that the access is a \u201cread\u201d, otherwise the logic will read another 8x8bits words while considering the operation as a \u201cwrite\u201d. To summarize: 8x I2C 8bits-words received corresponds to a FIRE register address to read. 16x I2C 8bits-words received corresponds to the FIRE register address and the data to write Read or write of 1 word will generate a \u201cdecode1c\u201d response (generated by the AXI bridges) written to the I2C FIFO As soon as a word is written in the I2C IP at @0x38, then \u201ci2c_ctrl_mac\u201d picks the data as an address and accesses the appropriate component. If required access is a \u201cread\u201d, then the data collected from the component is written to the axi_iix TX fifo. If the required access is a \u201cwrite\u201d, then the data is read by the \u201ci2c_ctrl_mac\u201d and sent to the appropriate component.","title":"Specific DDIMM I2C path"},{"location":"blocs/enablement2/#host-fire-memory-mapping-and-access","text":"a. Memory mapping The host offers 2 types of accesses. First of them deals with its own internal registers. Most used among them are: FML (FIRE Miscellaneous Library) containing mainly the Fire version and the reset of the devices C3S (OpenCAPI Command and Configure Sequencer) used to manually create an OMI frame (called flit) FBIST (Function Built-In Self Test) used to automatically generate and check high bandwidth traffic on the OMI links. The host can also access all memory mapping of the DDIMM devices (up to 4 devices) Table 1: FIRE memory space","title":"Host / FIRE memory mapping and Access"},{"location":"blocs/enablement2/#example-of-fire-internal-register","text":"","title":"Example of FIRE internal register"},{"location":"blocs/enablement2/#i-read-fire_version-at-0x00-of-fml-register","text":"python3 omi.py read -c fire -r 0x100000000000000 Rd Fire Addr 0x100000000000000 : 0x000000003e29c7d2 This register contains [31:29]: \u2018001\u2019: frequency used for the internal clock of the FPGA which determines the OMI link frequency [ 1= 21.33 GBPS, 2 =23.46 GBPS, 3=25.6 GBPS] [28]: \u20181\u2019: dirty bit is used when the current image contains change not committed to the git version control [27:0]: \u201829c7d2\u2019 is the git level of the code","title":"i. Read FIRE_VERSION at @0x00 of FML register"},{"location":"blocs/enablement2/#ii-resetunreset-the-ddimm0-device","text":"Reseting the DDIMMs is performed by the host. python3 omi.py read -c fire -r 0x100000000000004 Rd Fire Addr 0x100000000000004 : 0x000000000000003f Reset the DDIMM0 (bit3) python3 omi.py write -c fire -r 0x100000000000004 -d 000000037 Wr Fire Addr 0x100000000000004 : 0x0000000000000037 Writing check : Success python3 omi.py write -c fire -r 0x100000000000004 -d 000000037 Wr Fire Addr 0x100000000000004 : 0x000000000000003f Writing check : Success","title":"ii.    Reset/unreset the DDIMM0 device"},{"location":"blocs/enablement2/#iii-bad-address-access","text":"As soon as a bad i2C address is accessed, you may encounter one of the 2 different types of answer (with different severity): The answer \u201cdec0de1c\u201d will be sent by AMD/Xilinx axi crossbar as an answer to an unknown address (out of range) python3 omi.py read -c fire -r 0x1000F0000000004 Rd Fire Addr 0x1000f0000000004 : 0x00000000dec0de1c The answer \u201cdec0deff\u201d will be sent as an answer to address that is not modulo 4. ~/python/v6 $ python3 omi.py read -c fire -r 0x100000000000000 Rd Fire Addr 0x100000000000000 : 0x00000000335b5587 ~/python/v6 $ python3 omi.py read -c fire -r 0x100000000000001 Rd Fire Addr 0x100000000000001 : 0x00000000dec0deff ~/python/v6 $ python3 omi.py read -c fire -r 0x100000000000002 Rd Fire Addr 0x100000000000002 : 0x00000000dec0deff ~/python/v6 $ python3 omi.py read -c fire -r 0x100000000000003 Rd Fire Addr 0x100000000000003 : 0x00000000dec0deff ~/python/v6 $ python3 omi.py read -c fire -r 0x100000000000004 Rd Fire Addr 0x100000000000004 : 0x000000000000003f In the event you have modified the hdl design and not properly taken care of a memory range, an I2C error will be raised, and a reset of the fire chip will be needed if you access a bad address in an unallowed range! python3 omi.py read -c fire -r 0xin range but not answering address OSError: [Errno 5] Input/output error When this occurs a reset of the chip is required.","title":"iii.   Bad address access"},{"location":"blocs/enablement2/#omi-ddimm-ocmb-memory-mapping-and-access","text":"Contact Microchip support to obtain detailed information on firmware","title":"OMI DDIMM OCMB memory mapping and access"},{"location":"blocs/enablement2/#a-memory-mapping","text":"An EXPLORER register can be accessed in two ways: Directly through I2C. The user will need to select the port of the DDIMM to switch the I2C path to the EXPLORER he wants to access Indirectly through FIRE. The OMI links between FIRE and EXPLORER need to be trained to use the \u201cin-band\u201d access. To select the EXPLORER he wants to access, the user will use a specific address depending on the port number. Each EXPLORER register can be accessed through different addresses. The reference used is the Microchip \"Explorer_registers_Mips_view.pdf\" document. The 0x808xxxx registers are ordered by pair but can be accessed alone or by pair. As an example, let\u2019s access the register 0x8084168: OCMB - MB_SIM_MMIO_OTRCFG76_LEFT and 0x808416C: OCMB - MB_SIM_MMIO_OTRCFG76_RIGHT. They can be accessed either by their \u00ab register address \u00bb, by their \u00ab SCOM address \u00bb, by their \u00ab MMIO address \u00bb or by their \u00ab FIRE adress \u00bb: Register Address : @0x08084168 and @0x0808416C (32 bits access) I2C Register Address : @0xA8084168 and @0xA808416C (32 bits access) SCOM Address: Reg@0x8084168/C >> 3 => SCOM@ 0x801082D (64 bits access) MMIO Address: Reg@8084168/C => MMIO@ @0026C/8 (32 bits access) FIRE Address: => 0x3001000140084168 (64 bits access) To access different slots through FIRE, use the appropriate offset: DDIM_0_CFG / Port A: 0x3001_0001_4008_4168 DDIM_1_CFG / Port B: 0x3001_0401_4008_4168","title":"a.  Memory mapping"},{"location":"blocs/enablement2/#b-registers-access","text":"","title":"b.  Registers access"},{"location":"blocs/enablement2/#i-i2c-access-at-any-time-and-directly-in-explorer-chip","text":"tututututttuDDIMM / Port is selected by the I2C switch on the Tormem adapter board python3 omi.py initpath -d a #(done once to select the right OMI DDIMM / Port) MB_SIM_MMIO_OTRCFG76_LEFT + MB_SIM_MMIO_OTRCFG76_RIGHT 64 bits Read SCOM@ @801082D => 0x0000000f_00000000 python3 omi.py read -c exp -r 0801082D => 0x0000000f00000000 64 bits Write SCOM@ @801082D => 0x000000ff_00000000 python3 omi.py write -c exp -r 0801082D -d 0x0000ff00000000 MB_SIM_MMIO_OTRCFG76_LEFT => Reg @0x8084168 I2C Reg @0xA8084168 = SCOM @0801082D 32 bits Read Reg@ @0x8084168 => 0000000F python3 omi.py readreg -c exp -r 0x8084168 =>0x0000000F 32 bits Write Reg@ @0x8084168 => 000000FF (always start by lower address pair and then upper address pair) python3 omi.py writereg -c exp -r 0x8084168 -d 0x000000FF MB_SIM_MMIO_OTRCFG76_RIGHT => Reg @0x808416C = I2C Reg @0xA808416C = SCOM @0801082D 32 bits Read Reg@ @0x808416C => 00000000 python3 omi.py readreg -c exp -r 0x808416C => 0x00000000 32 bits Write Reg@ @0x808416C => 000000AA (always start by lower address pair and then upper address pair) python3 omi.py writereg -c exp -r 0x808416C -d 0x000000AA","title":"i.  I2C access (at any time and directly in explorer chip)"},{"location":"blocs/enablement2/#ii-in-band-access-using-the-fire-ddimm_0-mmio-register-address","text":"(access is done through FIRE only after OMI Links are trained) DDIMM / Port is selected by the address used DDIM_0_MMIO / Port A: 0x3001_0001_4008_4168 DDIM_1_MMIO / Port B: 0x3001_0401_4008_4168 MB_SIM_MMIO_O0MBIT_O0DID_LEFT + MB_SIM_MMIO_O0MBIT_O0DID_RIGHT 64 bits Read Reg@ @08084168 => 0x00000f_00000000 64 bits Write Reg@ @08084168 => 0x0000ff_00000000 python3 omi.py read -c fire -r 0x3001000140084168 => 0x0000000f00000000 64 bits Write Reg@ @08084168 => 0x0000ff_00000000 MB_SIM_MMIO_OTRCFG76_LEFT => MMIO @0026C = Reg @0x8084168 = SCOM @0801082D 32 bits Read MMIO@ @0026C => 0000000F 32 bits Write MMIO@ @0026C => 000000FF python3 omi.py read -c fire -r 0x200100000000026c => 0x000000000000000f 32 bits Write MMIO@ @0026C => 000000FF python3 omi.py write -c fire -r 0x3001000140084168 -d 0x000000ff00000000 MB_SIM_MMIO_OTRCFG76_LEFT => MMIO @0026C = Reg @0x8084168 = SCOM @0801082D 32 bits Read MMIO@ @0026C => 0000000F python3 omi.py read -c fire -r 0x200100000000026c => 0x000000000000000f 32 bits Write MMIO@ @0026C => 000000FF MB_SIM_MMIO_OTRCFG76_RIGHT => MMIO @00268 = Reg @0x808416C = SCOM @0801082D 32 bits Read MMIO@ @00268 => 00000000 python3 omi.py write -c fire -r 0x200100000000026c -d 0x000000ff MB_SIM_MMIO_OTRCFG76_RIGHT => MMIO @00268 = Reg @0x808416C = SCOM @0801082D 32 bits Read MMIO@ @00268 => 00000000 32 bits Write MMIO@ @00268 => 00000000 python3 omi.py read -c fire -r 0x2001000000000268 => 0x0000000000000000 32 bits Write MMIO@ @00268 => 00000000 Notice the address swap with 32 bits access! MMIO @0026C => Reg @0x8084168 python3 omi.py write -c fire -r 0x2001000000000268 -d 0x00000000 Notice the address swap with 32 bits access! MMIO @0026C => Reg @0x8084168","title":"ii. In-Band access using the FIRE DDIMM_0 MMIO register address"},{"location":"blocs/enablement2/#iii-in-band-access-using-c3s-to-manually-build-a-flit","text":"(access is done through Fire only after OMI Links are trained) Pre-requisite => Only allow template 0 32 bits Read MMIO@ @0026C => FADAFAAB Control array => C3S RESP WRITE ADDR RESET python3 omi.py read -c fire -r 0x2001000000000224 => 0x00000221 python3 omi.py write -c fire -r 0x2001000000000224 -d 0x00000001 32 bits Read MMIO@ @0026C => FADAFAAB Control array => C3S RESP WRITE ADDR RESET Data array python3 omi.py write -c fire -r 0x0101000000030004 -d 0x0000000000000200 Data array Flow Array python3 omi.py write -c fire -r 0x010100000000000E -d 0x0000000000000000 python3 omi.py write -c fire -r 0x0101000000000006 -d 0x0000000040000000 python3 omi.py write -c fire -r 0x0101000000000005 -d 0x0000000000000000 python3 omi.py write -c fire -r 0x0101000000000004 -d 0x000000000026C000 python3 omi.py write -c fire -r 0x0101000000000003 -d 0x0000000000E00000 Flow Array Control Array python3 omi.py write -c fire -r 0x0101000000020000 -d 0x0000000080000001 python3 omi.py write -c fire -r 0x0101000000020100 -d 0x0000000000000100 Control Array Response Array to access 0x26C~64/4=B, read 1020B python3 omi.py read -c fire -r 0x0101000000030000 => 0x0000000000000008 python3 omi.py write -c fire -r 0x0101000000030000 -d 0x0000000000000009 python3 omi.py read -c fire -r 0x0101000000030000 => 0x0000000000000008 python3 omi.py read -c fire -r 0x0101000000030000 => 0x0000000000000008 python3 omi.py write -c fire -r 0x0101000000030000 -d 0x000000000000000A Response Array to access 0x26C~64/4=B, read 1020B 32 bits Write MMIO@ @0026C => ABCDEFAA python3 omi.py read -c fire -r 0x010100000001020B => 0x00000000FADAFAAB 32 bits Write MMIO@ @0026C => ABCDEFAA Flow Array Data Array python3 omi.py write -c fire -r 0x010100000000000E -d 0x0000000000000001 python3 omi.py write -c fire -r 0x0101000000000006 -d 0x0000000040000000 python3 omi.py write -c fire -r 0x0101000000000005 -d 0x0000000000000000 python3 omi.py write -c fire -r 0x0101000000000004 -d 0x000000000026C000 python3 omi.py write -c fire -r 0x0101000000000003 -d 0x0000000000E10000 Flow Array Control Array python3 omi.py write -c fire -r 0x0101000000020000 -d 0x0000000080000001 python3 omi.py write -c fire -r 0x010100000000010B -d 0x00000000ABCDEFAA python3 omi.py write -c fire -r 0x0101000000020100 -d 0x0000000080000002 python3 omi.py write -c fire -r 0x0101000000020200 -d 0x0000000080000003 python3 omi.py write -c fire -r 0x0101000000020300 -d 0x0000000000000100 Control Array Reassign default value for supported templates python3 omi.py write -c fire -r 0x2001000000000224 -d 0x00000221 python3 omi.py read -c fire -r 0x0101000000030000 => 0x0000000000000008 python3 omi.py write -c fire -r 0x0101000000030000 -d 0x0000000000000009 python3 omi.py read -c fire -r 0x0101000000030000 => 0x0000000000000008 python3 omi.py read -c fire -r 0x0101000000030000 => 0x0000000000000008 python3 omi.py write -c fire -r 0x0101000000030000 -d 0x000000000000000A Reassign default value for supported templates python3 omi.py write -c fire -r 0x2001000000000224 -d 0x00000221","title":"iii.    In-Band access using C3S to manually build a Flit"},{"location":"blocs/enablement_details/","text":"OMI ENABLEMENT DETAILS Host / FIRE memory mapping and Access a. Memory mapping The host offers 2 types of accesses. First of them deals with its own internal registers. Most used among them are: FML (FIRE Miscellaneous Library) containing mainly the Fire version and the reset of the devices C3S (OpenCAPI Command and Configure Sequencer) used to manually create an OMI frame (called flit) FBIST (Function Built-In Self Test) used to automatically generate and check high bandwidth traffic on the OMI links. The host can also access all memory mapping of the DDIMM devices (up to 4 devices) \u200b Table 1: FIRE memory space Example of FIRE internal register i. Read FIRE_VERSION in register @0x00 of FML Group python3 omi.py read -c fire -r 0x100000000000000 Rd Fire Addr 0x100000000000000 : 0x000000003e29c7d2 This register contains [31:29]: \u2018001\u2019: frequency used for the internal clock of the FPGA which determines the OMI link frequency [ 1= 21.33 GBPS, 2 =23.46 GBPS, 3=25.6 GBPS] [28]: \u20181\u2019: dirty bit is used when the current image contains change not committed to the git version control [27:0]: \u201829c7d2\u2019 is the git level of the code ii. Reset/unreset the DDIMM0 device Reseting the DDIMMs is performed by the host. python3 omi.py read -c fire -r 0x100000000000004 Rd Fire Addr 0x100000000000004 : 0x000000000000003f Reset the DDIMM0 (bit3) python3 omi.py write -c fire -r 0x100000000000004 -d 000000037 Wr Fire Addr 0x100000000000004 : 0x0000000000000037 Writing check : Success python3 omi.py write -c fire -r 0x100000000000004 -d 000000037 Wr Fire Addr 0x100000000000004 : 0x000000000000003f Writing check : Success iii. Bad address access As soon as a bad i2C address is accessed, you may encounter one of the 4 different types of error answer: The answer \u201cdec0de1c\u201d will be sent by AMD/Xilinx AXI crossbar as an answer to an unknown address (out of range, as defined for example in axi_regs_32.vhdl python3 omi.py read -c fire -r 0x1000F0000000004 Rd Fire Addr 0x1000f0000000004 : 0x00000000dec0de1c The answer \u201cdec0deff\u201d will be sent as an answer to address that is not modulo 4. ~/python/v6 $ python3 omi.py read -c fire -r 0x100000000000000 Rd Fire Addr 0x100000000000000 : 0x00000000335b5587 ~/python/v6 $ python3 omi.py read -c fire -r 0x100000000000001 Rd Fire Addr 0x100000000000001 : 0x00000000dec0deff ~/python/v6 $ python3 omi.py read -c fire -r 0x100000000000002 Rd Fire Addr 0x100000000000002 : 0x00000000dec0deff ~/python/v6 $ python3 omi.py read -c fire -r 0x100000000000003 Rd Fire Addr 0x100000000000003 : 0x00000000dec0deff ~/python/v6 $ python3 omi.py read -c fire -r 0x100000000000004 Rd Fire Addr 0x100000000000004 : 0x000000000000003f The answer \u201cdec0de00\u201d will be sent as an answer to a register address that the hardware has not preset. ~/python/v6 $ python3 omi.py read -c fire -r 0x101000000030008 Rd Fire Addr 0x101000000030008 : 0x00000000dec0de00 The answer \u201cdec0de0b\u201d will be sent as an answer to an address existing in the AXI range definition, but the hardware doesn't handle. ~/python/v6 $ python3 omi.py read -c fire -r 0x101000000030040 Rd Fire Addr 0x101000000030040 : 0x00000000dec0de0b In the event you have modified the hdl design and not properly taken care of a memory range, an I2C error will be raised, and a reset of the fire chip will be needed if you access a bad address in an unallowed range! python3 omi.py read -c fire -r 0x<in range but not answering address> OSError: [Errno 5] Input/output error Note: When this occurs a reset of the chip is required. OMI DDIMM OCMB memory mapping and access Contact Microchip support to obtain detailed information on firmware Following propositions are only examples provided to help the discovery of OMI technology. a. Memory mapping An EXPLORER register can be accessed in two ways: Directly through I2C. The user will need to select the port of the DDIMM to switch the I2C path to the EXPLORER he wants to access Indirectly through FIRE. The OMI links between FIRE and EXPLORER need to be trained to use the \u201cin-band\u201d access. To select the EXPLORER register he wants to access, the user will use a specific address depending on the port number. Each EXPLORER register can be accessed through different addresses. The reference used is the Microchip \"Explorer_registers_Mips_view.pdf\" document. The 0x808xxxx registers are ordered by pair but can be accessed alone or by pair. As an example, let\u2019s access the register 0x8084168: OCMB - MB_SIM_MMIO_OTRCFG76_LEFT and 0x808416C: OCMB - MB_SIM_MMIO_OTRCFG76_RIGHT. They can be accessed either by their \u00ab register address \u00bb, by their \u00ab SCOM address \u00bb, by their \u00ab MMIO address \u00bb or by their \u00ab FIRE adress \u00bb: Register Address : @0x08084168 and @0x0808416C (32 bits access) I2C Register Address : @0xA8084168 and @0xA808416C (32 bits access) SCOM Address: Reg@0x8084168/C >> 3 => SCOM@ 0x801082D (64 bits access) MMIO Address: Reg@8084168/C => MMIO@ @0026C/8 (32 bits access) FIRE Address: => 0x3001000140084168 (64 bits access) To access different slots through FIRE, use the appropriate offset: DDIM_0_CFG / Port A: 0x3001_0001_4008_4168 DDIM_1_CFG / Port B: 0x3001_0401_4008_4168 b. Registers access i. I2C access (at any time and directly in EXPLORER chip) DDIMM / Port is selected by the I2C switch on the Tormem adapter board python3 omi.py initpath -d a #(done once to select the right OMI DDIMM / Port) MB_SIM_MMIO_OTRCFG76_LEFT + MB_SIM_MMIO_OTRCFG76_RIGHT 64 bits Read SCOM@ @801082D => 0x0000000f_00000000 python3 omi.py read -c exp -r 0801082D => 0x0000000f00000000 64 bits Write SCOM@ @801082D => 0x000000ff_00000000 python3 omi.py write -c exp -r 0801082D -d 0x0000ff00000000 MB_SIM_MMIO_OTRCFG76_LEFT => Reg @0x8084168 I2C Reg @0xA8084168 = SCOM @0801082D 32 bits Read Reg@ @0x8084168 => 0000000F python3 omi.py readreg -c exp -r 0x8084168 =>0x0000000F 32 bits Write Reg@ @0x8084168 => 000000FF (always start by lower address pair and then upper address pair) python3 omi.py writereg -c exp -r 0x8084168 -d 0x000000FF MB_SIM_MMIO_OTRCFG76_RIGHT => Reg @0x808416C = I2C Reg @0xA808416C = SCOM @0801082D 32 bits Read Reg@ @0x808416C => 00000000 python3 omi.py readreg -c exp -r 0x808416C => 0x00000000 32 bits Write Reg@ @0x808416C => 000000AA (always start by lower address pair and then upper address pair) python3 omi.py writereg -c exp -r 0x808416C -d 0x000000AA ii. In-Band access using the FIRE DDIMM_0 MMIO register address (access is done through FIRE only after OMI Links are trained) DDIMM / Port is selected by the address used DDIM_0_MMIO / Port A: 0x3001_0001_4008_4168 DDIM_1_MMIO / Port B: 0x3001_0401_4008_4168 MB_SIM_MMIO_O0MBIT_O0DID_LEFT + MB_SIM_MMIO_O0MBIT_O0DID_RIGHT 64 bits Read Reg@ @08084168 => 0x00000f_00000000 64 bits Write Reg@ @08084168 => 0x0000ff_00000000 python3 omi.py read -c fire -r 0x3001000140084168 => 0x0000000f00000000 64 bits Write Reg@ @08084168 => 0x0000ff_00000000 MB_SIM_MMIO_OTRCFG76_LEFT => MMIO @0026C = Reg @0x8084168 = SCOM @0801082D 32 bits Read MMIO@ @0026C => 0000000F 32 bits Write MMIO@ @0026C => 000000FF python3 omi.py read -c fire -r 0x200100000000026c => 0x000000000000000f 32 bits Write MMIO@ @0026C => 000000FF python3 omi.py write -c fire -r 0x3001000140084168 -d 0x000000ff00000000 MB_SIM_MMIO_OTRCFG76_LEFT => MMIO @0026C = Reg @0x8084168 = SCOM @0801082D 32 bits Read MMIO@ @0026C => 0000000F python3 omi.py read -c fire -r 0x200100000000026c => 0x000000000000000f 32 bits Write MMIO@ @0026C => 000000FF MB_SIM_MMIO_OTRCFG76_RIGHT => MMIO @00268 = Reg @0x808416C = SCOM @0801082D 32 bits Read MMIO@ @00268 => 00000000 python3 omi.py write -c fire -r 0x200100000000026c -d 0x000000ff MB_SIM_MMIO_OTRCFG76_RIGHT => MMIO @00268 = Reg @0x808416C = SCOM @0801082D 32 bits Read MMIO@ @00268 => 00000000 32 bits Write MMIO@ @00268 => 00000000 python3 omi.py read -c fire -r 0x2001000000000268 => 0x0000000000000000 32 bits Write MMIO@ @00268 => 00000000 Notice the address swap with 32 bits access! MMIO @0026C => Reg @0x8084168 python3 omi.py write -c fire -r 0x2001000000000268 -d 0x00000000 Notice the address swap with 32 bits access! MMIO @0026C => Reg @0x8084168 iii. In-Band access using C3S to manually build a Flit (access is done through Fire only after OMI Links are trained) Pre-requisite => Only template 0 is allowed. 32 bits Read MMIO@ @0026C => FADAFAAB Control array => C3S RESP WRITE ADDR RESET python3 omi.py read -c fire -r 0x2001000000000224 => 0x00000221 python3 omi.py write -c fire -r 0x2001000000000224 -d 0x00000001 32 bits Read MMIO@ @0026C => FADAFAAB Control array => C3S RESP WRITE ADDR RESET Data array python3 omi.py write -c fire -r 0x0101000000030004 -d 0x0000000000000200 Data array Flow Array python3 omi.py write -c fire -r 0x010100000000000E -d 0x0000000000000000 python3 omi.py write -c fire -r 0x0101000000000006 -d 0x0000000040000000 python3 omi.py write -c fire -r 0x0101000000000005 -d 0x0000000000000000 python3 omi.py write -c fire -r 0x0101000000000004 -d 0x000000000026C000 python3 omi.py write -c fire -r 0x0101000000000003 -d 0x0000000000E00000 Flow Array Control Array python3 omi.py write -c fire -r 0x0101000000020000 -d 0x0000000080000001 python3 omi.py write -c fire -r 0x0101000000020100 -d 0x0000000000000100 Control Array Response Array to access 0x26C~64/4=B, read 1020B python3 omi.py read -c fire -r 0x0101000000030000 => 0x0000000000000008 python3 omi.py write -c fire -r 0x0101000000030000 -d 0x0000000000000009 python3 omi.py read -c fire -r 0x0101000000030000 => 0x0000000000000008 python3 omi.py read -c fire -r 0x0101000000030000 => 0x0000000000000008 python3 omi.py write -c fire -r 0x0101000000030000 -d 0x000000000000000A Response Array to access 0x26C~64/4=B, read 1020B 32 bits Write MMIO@ @0026C => ABCDEFAA python3 omi.py read -c fire -r 0x010100000001020B => 0x00000000FADAFAAB 32 bits Write MMIO@ @0026C => ABCDEFAA Flow Array Data Array python3 omi.py write -c fire -r 0x010100000000000E -d 0x0000000000000001 python3 omi.py write -c fire -r 0x0101000000000006 -d 0x0000000040000000 python3 omi.py write -c fire -r 0x0101000000000005 -d 0x0000000000000000 python3 omi.py write -c fire -r 0x0101000000000004 -d 0x000000000026C000 python3 omi.py write -c fire -r 0x0101000000000003 -d 0x0000000000E10000 Flow Array Control Array python3 omi.py write -c fire -r 0x0101000000020000 -d 0x0000000080000001 python3 omi.py write -c fire -r 0x010100000000010B -d 0x00000000ABCDEFAA python3 omi.py write -c fire -r 0x0101000000020100 -d 0x0000000080000002 python3 omi.py write -c fire -r 0x0101000000020200 -d 0x0000000080000003 python3 omi.py write -c fire -r 0x0101000000020300 -d 0x0000000000000100 Control Array Reassign default value for supported templates python3 omi.py write -c fire -r 0x2001000000000224 -d 0x00000221 python3 omi.py read -c fire -r 0x0101000000030000 => 0x0000000000000008 python3 omi.py write -c fire -r 0x0101000000030000 -d 0x0000000000000009 python3 omi.py read -c fire -r 0x0101000000030000 => 0x0000000000000008 python3 omi.py read -c fire -r 0x0101000000030000 => 0x0000000000000008 python3 omi.py write -c fire -r 0x0101000000030000 -d 0x000000000000000A Reassign default value for supported templates python3 omi.py write -c fire -r 0x2001000000000224 -d 0x00000221","title":"OMI ENABLEMENT DETAILS"},{"location":"blocs/enablement_details/#omi-enablement-details","text":"","title":"OMI ENABLEMENT DETAILS"},{"location":"blocs/enablement_details/#host-fire-memory-mapping-and-access","text":"a. Memory mapping The host offers 2 types of accesses. First of them deals with its own internal registers. Most used among them are: FML (FIRE Miscellaneous Library) containing mainly the Fire version and the reset of the devices C3S (OpenCAPI Command and Configure Sequencer) used to manually create an OMI frame (called flit) FBIST (Function Built-In Self Test) used to automatically generate and check high bandwidth traffic on the OMI links. The host can also access all memory mapping of the DDIMM devices (up to 4 devices) \u200b Table 1: FIRE memory space","title":"Host / FIRE memory mapping and Access"},{"location":"blocs/enablement_details/#example-of-fire-internal-register","text":"","title":"Example of FIRE internal register"},{"location":"blocs/enablement_details/#i-read-fire_version-in-register-0x00-of-fml-group","text":"python3 omi.py read -c fire -r 0x100000000000000 Rd Fire Addr 0x100000000000000 : 0x000000003e29c7d2 This register contains [31:29]: \u2018001\u2019: frequency used for the internal clock of the FPGA which determines the OMI link frequency [ 1= 21.33 GBPS, 2 =23.46 GBPS, 3=25.6 GBPS] [28]: \u20181\u2019: dirty bit is used when the current image contains change not committed to the git version control [27:0]: \u201829c7d2\u2019 is the git level of the code","title":"i. Read FIRE_VERSION in register @0x00 of FML Group"},{"location":"blocs/enablement_details/#ii-resetunreset-the-ddimm0-device","text":"Reseting the DDIMMs is performed by the host. python3 omi.py read -c fire -r 0x100000000000004 Rd Fire Addr 0x100000000000004 : 0x000000000000003f Reset the DDIMM0 (bit3) python3 omi.py write -c fire -r 0x100000000000004 -d 000000037 Wr Fire Addr 0x100000000000004 : 0x0000000000000037 Writing check : Success python3 omi.py write -c fire -r 0x100000000000004 -d 000000037 Wr Fire Addr 0x100000000000004 : 0x000000000000003f Writing check : Success","title":"ii.    Reset/unreset the DDIMM0 device"},{"location":"blocs/enablement_details/#iii-bad-address-access","text":"As soon as a bad i2C address is accessed, you may encounter one of the 4 different types of error answer: The answer \u201cdec0de1c\u201d will be sent by AMD/Xilinx AXI crossbar as an answer to an unknown address (out of range, as defined for example in axi_regs_32.vhdl python3 omi.py read -c fire -r 0x1000F0000000004 Rd Fire Addr 0x1000f0000000004 : 0x00000000dec0de1c The answer \u201cdec0deff\u201d will be sent as an answer to address that is not modulo 4. ~/python/v6 $ python3 omi.py read -c fire -r 0x100000000000000 Rd Fire Addr 0x100000000000000 : 0x00000000335b5587 ~/python/v6 $ python3 omi.py read -c fire -r 0x100000000000001 Rd Fire Addr 0x100000000000001 : 0x00000000dec0deff ~/python/v6 $ python3 omi.py read -c fire -r 0x100000000000002 Rd Fire Addr 0x100000000000002 : 0x00000000dec0deff ~/python/v6 $ python3 omi.py read -c fire -r 0x100000000000003 Rd Fire Addr 0x100000000000003 : 0x00000000dec0deff ~/python/v6 $ python3 omi.py read -c fire -r 0x100000000000004 Rd Fire Addr 0x100000000000004 : 0x000000000000003f The answer \u201cdec0de00\u201d will be sent as an answer to a register address that the hardware has not preset. ~/python/v6 $ python3 omi.py read -c fire -r 0x101000000030008 Rd Fire Addr 0x101000000030008 : 0x00000000dec0de00 The answer \u201cdec0de0b\u201d will be sent as an answer to an address existing in the AXI range definition, but the hardware doesn't handle. ~/python/v6 $ python3 omi.py read -c fire -r 0x101000000030040 Rd Fire Addr 0x101000000030040 : 0x00000000dec0de0b In the event you have modified the hdl design and not properly taken care of a memory range, an I2C error will be raised, and a reset of the fire chip will be needed if you access a bad address in an unallowed range! python3 omi.py read -c fire -r 0x<in range but not answering address> OSError: [Errno 5] Input/output error Note: When this occurs a reset of the chip is required.","title":"iii.   Bad address access"},{"location":"blocs/enablement_details/#omi-ddimm-ocmb-memory-mapping-and-access","text":"Contact Microchip support to obtain detailed information on firmware Following propositions are only examples provided to help the discovery of OMI technology.","title":"OMI DDIMM OCMB memory mapping and access"},{"location":"blocs/enablement_details/#a-memory-mapping","text":"An EXPLORER register can be accessed in two ways: Directly through I2C. The user will need to select the port of the DDIMM to switch the I2C path to the EXPLORER he wants to access Indirectly through FIRE. The OMI links between FIRE and EXPLORER need to be trained to use the \u201cin-band\u201d access. To select the EXPLORER register he wants to access, the user will use a specific address depending on the port number. Each EXPLORER register can be accessed through different addresses. The reference used is the Microchip \"Explorer_registers_Mips_view.pdf\" document. The 0x808xxxx registers are ordered by pair but can be accessed alone or by pair. As an example, let\u2019s access the register 0x8084168: OCMB - MB_SIM_MMIO_OTRCFG76_LEFT and 0x808416C: OCMB - MB_SIM_MMIO_OTRCFG76_RIGHT. They can be accessed either by their \u00ab register address \u00bb, by their \u00ab SCOM address \u00bb, by their \u00ab MMIO address \u00bb or by their \u00ab FIRE adress \u00bb: Register Address : @0x08084168 and @0x0808416C (32 bits access) I2C Register Address : @0xA8084168 and @0xA808416C (32 bits access) SCOM Address: Reg@0x8084168/C >> 3 => SCOM@ 0x801082D (64 bits access) MMIO Address: Reg@8084168/C => MMIO@ @0026C/8 (32 bits access) FIRE Address: => 0x3001000140084168 (64 bits access) To access different slots through FIRE, use the appropriate offset: DDIM_0_CFG / Port A: 0x3001_0001_4008_4168 DDIM_1_CFG / Port B: 0x3001_0401_4008_4168","title":"a.  Memory mapping"},{"location":"blocs/enablement_details/#b-registers-access","text":"","title":"b.  Registers access"},{"location":"blocs/enablement_details/#i-i2c-access-at-any-time-and-directly-in-explorer-chip","text":"DDIMM / Port is selected by the I2C switch on the Tormem adapter board python3 omi.py initpath -d a #(done once to select the right OMI DDIMM / Port) MB_SIM_MMIO_OTRCFG76_LEFT + MB_SIM_MMIO_OTRCFG76_RIGHT 64 bits Read SCOM@ @801082D => 0x0000000f_00000000 python3 omi.py read -c exp -r 0801082D => 0x0000000f00000000 64 bits Write SCOM@ @801082D => 0x000000ff_00000000 python3 omi.py write -c exp -r 0801082D -d 0x0000ff00000000 MB_SIM_MMIO_OTRCFG76_LEFT => Reg @0x8084168 I2C Reg @0xA8084168 = SCOM @0801082D 32 bits Read Reg@ @0x8084168 => 0000000F python3 omi.py readreg -c exp -r 0x8084168 =>0x0000000F 32 bits Write Reg@ @0x8084168 => 000000FF (always start by lower address pair and then upper address pair) python3 omi.py writereg -c exp -r 0x8084168 -d 0x000000FF MB_SIM_MMIO_OTRCFG76_RIGHT => Reg @0x808416C = I2C Reg @0xA808416C = SCOM @0801082D 32 bits Read Reg@ @0x808416C => 00000000 python3 omi.py readreg -c exp -r 0x808416C => 0x00000000 32 bits Write Reg@ @0x808416C => 000000AA (always start by lower address pair and then upper address pair) python3 omi.py writereg -c exp -r 0x808416C -d 0x000000AA","title":"i.  I2C access (at any time and directly in EXPLORER chip)"},{"location":"blocs/enablement_details/#ii-in-band-access-using-the-fire-ddimm_0-mmio-register-address","text":"(access is done through FIRE only after OMI Links are trained) DDIMM / Port is selected by the address used DDIM_0_MMIO / Port A: 0x3001_0001_4008_4168 DDIM_1_MMIO / Port B: 0x3001_0401_4008_4168 MB_SIM_MMIO_O0MBIT_O0DID_LEFT + MB_SIM_MMIO_O0MBIT_O0DID_RIGHT 64 bits Read Reg@ @08084168 => 0x00000f_00000000 64 bits Write Reg@ @08084168 => 0x0000ff_00000000 python3 omi.py read -c fire -r 0x3001000140084168 => 0x0000000f00000000 64 bits Write Reg@ @08084168 => 0x0000ff_00000000 MB_SIM_MMIO_OTRCFG76_LEFT => MMIO @0026C = Reg @0x8084168 = SCOM @0801082D 32 bits Read MMIO@ @0026C => 0000000F 32 bits Write MMIO@ @0026C => 000000FF python3 omi.py read -c fire -r 0x200100000000026c => 0x000000000000000f 32 bits Write MMIO@ @0026C => 000000FF python3 omi.py write -c fire -r 0x3001000140084168 -d 0x000000ff00000000 MB_SIM_MMIO_OTRCFG76_LEFT => MMIO @0026C = Reg @0x8084168 = SCOM @0801082D 32 bits Read MMIO@ @0026C => 0000000F python3 omi.py read -c fire -r 0x200100000000026c => 0x000000000000000f 32 bits Write MMIO@ @0026C => 000000FF MB_SIM_MMIO_OTRCFG76_RIGHT => MMIO @00268 = Reg @0x808416C = SCOM @0801082D 32 bits Read MMIO@ @00268 => 00000000 python3 omi.py write -c fire -r 0x200100000000026c -d 0x000000ff MB_SIM_MMIO_OTRCFG76_RIGHT => MMIO @00268 = Reg @0x808416C = SCOM @0801082D 32 bits Read MMIO@ @00268 => 00000000 32 bits Write MMIO@ @00268 => 00000000 python3 omi.py read -c fire -r 0x2001000000000268 => 0x0000000000000000 32 bits Write MMIO@ @00268 => 00000000 Notice the address swap with 32 bits access! MMIO @0026C => Reg @0x8084168 python3 omi.py write -c fire -r 0x2001000000000268 -d 0x00000000 Notice the address swap with 32 bits access! MMIO @0026C => Reg @0x8084168","title":"ii. In-Band access using the FIRE DDIMM_0 MMIO register address"},{"location":"blocs/enablement_details/#iii-in-band-access-using-c3s-to-manually-build-a-flit","text":"(access is done through Fire only after OMI Links are trained) Pre-requisite => Only template 0 is allowed. 32 bits Read MMIO@ @0026C => FADAFAAB Control array => C3S RESP WRITE ADDR RESET python3 omi.py read -c fire -r 0x2001000000000224 => 0x00000221 python3 omi.py write -c fire -r 0x2001000000000224 -d 0x00000001 32 bits Read MMIO@ @0026C => FADAFAAB Control array => C3S RESP WRITE ADDR RESET Data array python3 omi.py write -c fire -r 0x0101000000030004 -d 0x0000000000000200 Data array Flow Array python3 omi.py write -c fire -r 0x010100000000000E -d 0x0000000000000000 python3 omi.py write -c fire -r 0x0101000000000006 -d 0x0000000040000000 python3 omi.py write -c fire -r 0x0101000000000005 -d 0x0000000000000000 python3 omi.py write -c fire -r 0x0101000000000004 -d 0x000000000026C000 python3 omi.py write -c fire -r 0x0101000000000003 -d 0x0000000000E00000 Flow Array Control Array python3 omi.py write -c fire -r 0x0101000000020000 -d 0x0000000080000001 python3 omi.py write -c fire -r 0x0101000000020100 -d 0x0000000000000100 Control Array Response Array to access 0x26C~64/4=B, read 1020B python3 omi.py read -c fire -r 0x0101000000030000 => 0x0000000000000008 python3 omi.py write -c fire -r 0x0101000000030000 -d 0x0000000000000009 python3 omi.py read -c fire -r 0x0101000000030000 => 0x0000000000000008 python3 omi.py read -c fire -r 0x0101000000030000 => 0x0000000000000008 python3 omi.py write -c fire -r 0x0101000000030000 -d 0x000000000000000A Response Array to access 0x26C~64/4=B, read 1020B 32 bits Write MMIO@ @0026C => ABCDEFAA python3 omi.py read -c fire -r 0x010100000001020B => 0x00000000FADAFAAB 32 bits Write MMIO@ @0026C => ABCDEFAA Flow Array Data Array python3 omi.py write -c fire -r 0x010100000000000E -d 0x0000000000000001 python3 omi.py write -c fire -r 0x0101000000000006 -d 0x0000000040000000 python3 omi.py write -c fire -r 0x0101000000000005 -d 0x0000000000000000 python3 omi.py write -c fire -r 0x0101000000000004 -d 0x000000000026C000 python3 omi.py write -c fire -r 0x0101000000000003 -d 0x0000000000E10000 Flow Array Control Array python3 omi.py write -c fire -r 0x0101000000020000 -d 0x0000000080000001 python3 omi.py write -c fire -r 0x010100000000010B -d 0x00000000ABCDEFAA python3 omi.py write -c fire -r 0x0101000000020100 -d 0x0000000080000002 python3 omi.py write -c fire -r 0x0101000000020200 -d 0x0000000080000003 python3 omi.py write -c fire -r 0x0101000000020300 -d 0x0000000000000100 Control Array Reassign default value for supported templates python3 omi.py write -c fire -r 0x2001000000000224 -d 0x00000221 python3 omi.py read -c fire -r 0x0101000000030000 => 0x0000000000000008 python3 omi.py write -c fire -r 0x0101000000030000 -d 0x0000000000000009 python3 omi.py read -c fire -r 0x0101000000030000 => 0x0000000000000008 python3 omi.py read -c fire -r 0x0101000000030000 => 0x0000000000000008 python3 omi.py write -c fire -r 0x0101000000030000 -d 0x000000000000000A Reassign default value for supported templates python3 omi.py write -c fire -r 0x2001000000000224 -d 0x00000221","title":"iii.    In-Band access using C3S to manually build a Flit"},{"location":"blocs/enablement_setup/","text":"OMI ENABLEMENT Setup HARDWARE DESCRIPTION For the purpose of open sourcing the design, a collaboration between OMI members led to a tuning of an OMIhost FPGA reference design \" Fire \" to be used in a VCU128 Card from AMD/Xilinx. With addition of a simple FMC+ connected add-on card, any OMI compatible memory DDIMM module can be evaluated. The setup allows evaluation of 2 DDIMMs modules in slots A and B. Some code is required to synchronize and test the OMI DDIMMs. Enablement example codes have been developed in Python and in C. Same functions are available. Either the code is executed in a companion raspberry pi or any I2C capable computer, or even in an embedded microblaze processor (in the latter case use the C version as it executes much faster) Python source code is available at : Python Code Python code documentation is available at : Python Documentation C source code is available at : C Code C code documentation is available at : C Documentation Enablement example code Checks I2C tree Synchronizes DDIMMs Executes simple transfers in memory (not published yet) Note: The Raspberry pi can host an Cronus server, should you want to evaluate OMI in a Cronus environment. REQUIREMENTS Requirements depends on what kind of experiments need to be conducted. Cronus with a raspberry pi hosting a Cronus server and dealing with I2C accesses (out of present scope) Standalone Python or C code running on Raspberry Pi or a PC with I2C capabilities Embedded PetaLinux with Microblaze next to Fire in the FPGA requires TFTP / NFS / DNS server to host boot and file system can run C standalone code (Python is too slow to execute in a timely manner) Standalone C code running on a no-OS Microblaze embedded processor (not developed yet) only requires a serial terminal (can be \"picocom\" using UART through programming USB cable) Minimum Hardware requirements : Procure the following: A VCU128 Board from AMD/Xilinx and a JTAG controlling PC (can be the Raspberry pi) An adapter board from Tormem . as of today only V1 is available Version 1 allows basic DDIMM interface Version 2 will also allow FIRE reset and power control of 12V, 3.3V and 1.8V. At least one DDIMM module A USB relay card to ensure automated fire reset / 3.3V / 12V POWER control (if using an adapter board version 1) Software requirements : Obtain an AMD/Xilinx Licence for Vivado. Requires 2018.3 version for this contribution (best timing results at maximum bandwidth). ENABLEMENT STEPS with an external I2C master git clone the \" vcu128_enablement \" repository of Fire design. First synthetize, implement and generate bitstream of \"FIRE\" design for the VCU128 using the specific branch as specified in the README.md file. git clone the https://github.com/OpenCAPI/omi_enablement/ and use /python or /c directory with a debugging raspberry pi or any computer with I2C capability to check you can see the design. Choose Python or C control, both will send requests through the I2C bus to the Fire design. Explorer chip are usually access through In band commands are dealt by Fire. ENABLEMENT STEPS with internal Microblaze as I2C master When using Tormem adapter board version 1, I2C control by Microblaze requires a hacking of the VCU128 board as there is no provision to connect an external cable. git clone the \" vcu128_enablement \" repository of Fire design. First synthetize, implement and generate bitstream of \"FIRE\" design for the VCU128 using the specific branch as specified in the README.md file. To prepare the integration of FIRE and microblaze structure, generate an IP of Fire design. Git clone the \" omi_enablement \" to get the necessary material to build a {Fire + Microblaze} structure. Hardware: Option 1 : re-create your own design {FIRE + Microblaze} From the \"hw/\" directory, use hw_script.sh and tcl_code.tcl to generate a microblaze environment. you'll be ask to provide the FIRE ip path from step 3. you'll get the .xsa file which is the only file required for the remaining steps. It contains a complete description of the hardware. Hardware Option 2: use pre-built hardware system.bit. Install petalinux (we used the 2021.1 version) Software Option 1: create your petalinux environment using petalinux-create, create a vcuomi project directory. petalinux-create --type project --template microblaze --name vcuomi remaining tasks: To Be described ... Software Option 2: Use pre_built linux Use https://github.com/OpenCAPI/omi_enablement/tree/main/petalinux content run the script.sh and then wsl@wsl:~/omi_enablement/petalinux$ petalinux-create --type project -s *.bsp wsl@wsl:~/omi_enablement/petalinux$ mkdir vcuomi/images && mkdir vcuomi/images/linux wsl@wsl:~/omi_enablement/petalinux$ cp -r linux/images/* vcuomi/images/linux/. copy the images/linux content to your tftp directory of the remote computer acting as a server. From the remote tftp/NFS server: copy the tftp/rootfs.tar.gz directory to your NFS directory. Adjust permissions accordingly. From petalinux installation dir use xsct -nolrwrap to load the system.bit into the fpga. open a picocom or any RS232 terminal on the FPGA RS232 link. trigger a boot of the microblaze with petalinux-boot. I2C architecture foreword I2C is either used in a traditional manner, ie Master issues a R or W to a I2C chip adress. The addressed chip also provides an internal register address. That's the case for EEPROM, PMIC (Power Managment IC), I2C muxes etc .. As far as FIRE and EXPLORER are concerned, they are accessed using different modes depending on which register is concerned. Internal registers are accessed through an indirect mecanism, and inband is possible for devices, hence this documentation. I2C tree I2C components Master: Raspberry pi or any I2C capable computer Host component from Apollo or VCU128 board containing a FPGA with a FIRE host design at @0x38 For each DDIMM : DDIMM EEPROM containing VPD data at I2C@0x50 PMIC1 and PMIC2 (Power Management Integrated Circuits) setting the Power supplied of the board at @0x4F and @0x67 OMI DDIMM OCMB (OpenCAPI Memory Buffer also called Explorer) at @0x20 Reset and power supply control DDIMM Exporer reset signal is controlled through an FMC+ connector lane and a FIRE FML register, while FIRE reset is required with an external logic. This logic can be easily performed with a set of USB controlled electromechanical relays hooked up to the controlling computer. The same relay board an control power supplies through the adapter power supply connector. Each development lab need to tune this signals to allow resetting FIRE and switch on and off power supplies at any time. Specific DDIMM I2C path Tormem adapter board can have up to 2 devices. Each of them can be accessed through I2C using a multiplexer switch. After a power on and Fire reset: Select the proper DDIMM I2C path (set the adapter mux accordingly) ~/vcu128_ctl_sh/i2c_reset.sh ; python3 omi.py initpath -d a To check with mux is selected, use the following command: python3 omi.py checkpath` Once Path is set, the init routine will power on the 2 DDIMM PMICS. No DDIMM selection, as it will power on the currently selected DDIMM. python3 omi.py init Once I2C path is set and DDIM is powered on, we can list the viewable devices using Adapter version 1: Typically, you will identify the FIRE host as @0x38, the OMI DDIMM device as @0x20, the EEPROM as @0x50, the 2 PMIC as @0x4F and 0x67 and the different muxes at @0x71 and 0x73 from the Adapter board. FIRE I2C is a slave component set with 0x38 as I2C address. This FIRE I2C provides access to all address mapping from the host side as well as from the device sides. After a reset of the Xilinx AXI-IIC IP initialization of the IP is preformed as follow: Soft reset (SOFTR @040) Slave Mode Select (CR @100) Enable AIX IIC controller (CR @100) Set I2C slave address to 0x38 (ADDR @110) Set an irq if fifo is full (16 locations filled) (RX_FIFO_PIRQ @120) The I2C protocol is not used as the typical one, meaning that any I2C access (either \u201cread\u201d or \u201cwrite\u201d) fills the I2C Rx FIFO with almost 1 word. The state machine associated to this I2C IP (i2c_ctrl_mac) is polling indefinitely the I2C IP (axi_iic). As soon as it detects that the Rx FIFO is not empty then 8x8bits words are read (even if only 1 byte was written). Afterwards if the FIFO is empty, it means that the access is a \u201cread\u201d, otherwise the logic will read another 8x8bits words while considering the operation as a \u201cwrite\u201d. To summarize: 8x I2C 8bits-words received corresponds to a FIRE register address to read. 16x I2C 8bits-words received corresponds to the FIRE register address and the data to write Read or write of 1 word will generate a \u201cdecode1c\u201d response (generated by the AXI bridges) written to the I2C FIFO As soon as a word is written in the I2C IP at @0x38, then \u201ci2c_ctrl_mac\u201d picks the data as an address and accesses the appropriate component. If required access is a \u201cread\u201d, then the data collected from the component is written to the axi_iix TX fifo. If the required access is a \u201cwrite\u201d, then the data is read by the \u201ci2c_ctrl_mac\u201d and sent to the appropriate component. Reading FIRE's ID register: It contains the git revision of the hardware build and few other information: python3 omi.py read -c fire -r 0x100000000000000 Rd Fire Addr 0x100000000000000 : 0x000000003e29c7d2 (This an example of git level) Conclusion At this level you should have all necessary hardware and software to access FIRE. Check Enablement details page to get further information on FIRE and EXPLORER registers and memory space accesses.","title":"OMI ENABLEMENT Setup"},{"location":"blocs/enablement_setup/#omi-enablement-setup","text":"","title":"OMI ENABLEMENT Setup"},{"location":"blocs/enablement_setup/#hardware-description","text":"For the purpose of open sourcing the design, a collaboration between OMI members led to a tuning of an OMIhost FPGA reference design \" Fire \" to be used in a VCU128 Card from AMD/Xilinx. With addition of a simple FMC+ connected add-on card, any OMI compatible memory DDIMM module can be evaluated. The setup allows evaluation of 2 DDIMMs modules in slots A and B. Some code is required to synchronize and test the OMI DDIMMs. Enablement example codes have been developed in Python and in C. Same functions are available. Either the code is executed in a companion raspberry pi or any I2C capable computer, or even in an embedded microblaze processor (in the latter case use the C version as it executes much faster) Python source code is available at : Python Code Python code documentation is available at : Python Documentation C source code is available at : C Code C code documentation is available at : C Documentation Enablement example code Checks I2C tree Synchronizes DDIMMs Executes simple transfers in memory (not published yet) Note: The Raspberry pi can host an Cronus server, should you want to evaluate OMI in a Cronus environment.","title":"HARDWARE DESCRIPTION"},{"location":"blocs/enablement_setup/#requirements","text":"Requirements depends on what kind of experiments need to be conducted. Cronus with a raspberry pi hosting a Cronus server and dealing with I2C accesses (out of present scope) Standalone Python or C code running on Raspberry Pi or a PC with I2C capabilities Embedded PetaLinux with Microblaze next to Fire in the FPGA requires TFTP / NFS / DNS server to host boot and file system can run C standalone code (Python is too slow to execute in a timely manner) Standalone C code running on a no-OS Microblaze embedded processor (not developed yet) only requires a serial terminal (can be \"picocom\" using UART through programming USB cable) Minimum Hardware requirements : Procure the following: A VCU128 Board from AMD/Xilinx and a JTAG controlling PC (can be the Raspberry pi) An adapter board from Tormem . as of today only V1 is available Version 1 allows basic DDIMM interface Version 2 will also allow FIRE reset and power control of 12V, 3.3V and 1.8V. At least one DDIMM module A USB relay card to ensure automated fire reset / 3.3V / 12V POWER control (if using an adapter board version 1) Software requirements : Obtain an AMD/Xilinx Licence for Vivado. Requires 2018.3 version for this contribution (best timing results at maximum bandwidth).","title":"REQUIREMENTS"},{"location":"blocs/enablement_setup/#enablement-steps-with-an-external-i2c-master","text":"git clone the \" vcu128_enablement \" repository of Fire design. First synthetize, implement and generate bitstream of \"FIRE\" design for the VCU128 using the specific branch as specified in the README.md file. git clone the https://github.com/OpenCAPI/omi_enablement/ and use /python or /c directory with a debugging raspberry pi or any computer with I2C capability to check you can see the design. Choose Python or C control, both will send requests through the I2C bus to the Fire design. Explorer chip are usually access through In band commands are dealt by Fire.","title":"ENABLEMENT STEPS with an external I2C master"},{"location":"blocs/enablement_setup/#enablement-steps-with-internal-microblaze-as-i2c-master","text":"When using Tormem adapter board version 1, I2C control by Microblaze requires a hacking of the VCU128 board as there is no provision to connect an external cable. git clone the \" vcu128_enablement \" repository of Fire design. First synthetize, implement and generate bitstream of \"FIRE\" design for the VCU128 using the specific branch as specified in the README.md file. To prepare the integration of FIRE and microblaze structure, generate an IP of Fire design. Git clone the \" omi_enablement \" to get the necessary material to build a {Fire + Microblaze} structure. Hardware: Option 1 : re-create your own design {FIRE + Microblaze} From the \"hw/\" directory, use hw_script.sh and tcl_code.tcl to generate a microblaze environment. you'll be ask to provide the FIRE ip path from step 3. you'll get the .xsa file which is the only file required for the remaining steps. It contains a complete description of the hardware. Hardware Option 2: use pre-built hardware system.bit. Install petalinux (we used the 2021.1 version) Software Option 1: create your petalinux environment using petalinux-create, create a vcuomi project directory. petalinux-create --type project --template microblaze --name vcuomi remaining tasks: To Be described ... Software Option 2: Use pre_built linux Use https://github.com/OpenCAPI/omi_enablement/tree/main/petalinux content run the script.sh and then wsl@wsl:~/omi_enablement/petalinux$ petalinux-create --type project -s *.bsp wsl@wsl:~/omi_enablement/petalinux$ mkdir vcuomi/images && mkdir vcuomi/images/linux wsl@wsl:~/omi_enablement/petalinux$ cp -r linux/images/* vcuomi/images/linux/. copy the images/linux content to your tftp directory of the remote computer acting as a server. From the remote tftp/NFS server: copy the tftp/rootfs.tar.gz directory to your NFS directory. Adjust permissions accordingly. From petalinux installation dir use xsct -nolrwrap to load the system.bit into the fpga. open a picocom or any RS232 terminal on the FPGA RS232 link. trigger a boot of the microblaze with petalinux-boot.","title":"ENABLEMENT STEPS with internal Microblaze as I2C master"},{"location":"blocs/enablement_setup/#i2c-architecture-foreword","text":"I2C is either used in a traditional manner, ie Master issues a R or W to a I2C chip adress. The addressed chip also provides an internal register address. That's the case for EEPROM, PMIC (Power Managment IC), I2C muxes etc .. As far as FIRE and EXPLORER are concerned, they are accessed using different modes depending on which register is concerned. Internal registers are accessed through an indirect mecanism, and inband is possible for devices, hence this documentation.","title":"I2C architecture foreword"},{"location":"blocs/enablement_setup/#i2c-tree","text":"","title":"I2C tree"},{"location":"blocs/enablement_setup/#i2c-components","text":"Master: Raspberry pi or any I2C capable computer Host component from Apollo or VCU128 board containing a FPGA with a FIRE host design at @0x38 For each DDIMM : DDIMM EEPROM containing VPD data at I2C@0x50 PMIC1 and PMIC2 (Power Management Integrated Circuits) setting the Power supplied of the board at @0x4F and @0x67 OMI DDIMM OCMB (OpenCAPI Memory Buffer also called Explorer) at @0x20","title":"I2C components"},{"location":"blocs/enablement_setup/#reset-and-power-supply-control","text":"DDIMM Exporer reset signal is controlled through an FMC+ connector lane and a FIRE FML register, while FIRE reset is required with an external logic. This logic can be easily performed with a set of USB controlled electromechanical relays hooked up to the controlling computer. The same relay board an control power supplies through the adapter power supply connector. Each development lab need to tune this signals to allow resetting FIRE and switch on and off power supplies at any time.","title":"Reset and power supply control"},{"location":"blocs/enablement_setup/#specific-ddimm-i2c-path","text":"Tormem adapter board can have up to 2 devices. Each of them can be accessed through I2C using a multiplexer switch. After a power on and Fire reset: Select the proper DDIMM I2C path (set the adapter mux accordingly) ~/vcu128_ctl_sh/i2c_reset.sh ; python3 omi.py initpath -d a To check with mux is selected, use the following command: python3 omi.py checkpath` Once Path is set, the init routine will power on the 2 DDIMM PMICS. No DDIMM selection, as it will power on the currently selected DDIMM. python3 omi.py init Once I2C path is set and DDIM is powered on, we can list the viewable devices using Adapter version 1: Typically, you will identify the FIRE host as @0x38, the OMI DDIMM device as @0x20, the EEPROM as @0x50, the 2 PMIC as @0x4F and 0x67 and the different muxes at @0x71 and 0x73 from the Adapter board. FIRE I2C is a slave component set with 0x38 as I2C address. This FIRE I2C provides access to all address mapping from the host side as well as from the device sides. After a reset of the Xilinx AXI-IIC IP initialization of the IP is preformed as follow: Soft reset (SOFTR @040) Slave Mode Select (CR @100) Enable AIX IIC controller (CR @100) Set I2C slave address to 0x38 (ADDR @110) Set an irq if fifo is full (16 locations filled) (RX_FIFO_PIRQ @120) The I2C protocol is not used as the typical one, meaning that any I2C access (either \u201cread\u201d or \u201cwrite\u201d) fills the I2C Rx FIFO with almost 1 word. The state machine associated to this I2C IP (i2c_ctrl_mac) is polling indefinitely the I2C IP (axi_iic). As soon as it detects that the Rx FIFO is not empty then 8x8bits words are read (even if only 1 byte was written). Afterwards if the FIFO is empty, it means that the access is a \u201cread\u201d, otherwise the logic will read another 8x8bits words while considering the operation as a \u201cwrite\u201d. To summarize: 8x I2C 8bits-words received corresponds to a FIRE register address to read. 16x I2C 8bits-words received corresponds to the FIRE register address and the data to write Read or write of 1 word will generate a \u201cdecode1c\u201d response (generated by the AXI bridges) written to the I2C FIFO As soon as a word is written in the I2C IP at @0x38, then \u201ci2c_ctrl_mac\u201d picks the data as an address and accesses the appropriate component. If required access is a \u201cread\u201d, then the data collected from the component is written to the axi_iix TX fifo. If the required access is a \u201cwrite\u201d, then the data is read by the \u201ci2c_ctrl_mac\u201d and sent to the appropriate component. Reading FIRE's ID register: It contains the git revision of the hardware build and few other information: python3 omi.py read -c fire -r 0x100000000000000 Rd Fire Addr 0x100000000000000 : 0x000000003e29c7d2 (This an example of git level)","title":"Specific DDIMM I2C path"},{"location":"blocs/enablement_setup/#conclusion","text":"At this level you should have all necessary hardware and software to access FIRE. Check Enablement details page to get further information on FIRE and EXPLORER registers and memory space accesses.","title":"Conclusion"},{"location":"blocs/fire/","text":"FIRE Description Description Fire is an OMI host FPGA reference design based on the OpenCAPI 3.1 Transaction and Data Layer Architecture Specification . The design was developed to be used in an \" Apollo \" card. This \" Apollo \" card was developed for use in doing post-silicon validation of OMI memory buffers as well as various DDIMM provider without the need for having an actual processor piece of silicon to drive the OMI traffic. A branch \" vcu128_enablement \" has been created to allow usage of Fire in a VCU128 board with a FMC+ connector and an adaptation board. Check for enablement information on the enablement page","title":"FIRE Host Side FPGA Description"},{"location":"blocs/fire/#fire-description","text":"","title":"FIRE Description"},{"location":"blocs/fire/#description","text":"Fire is an OMI host FPGA reference design based on the OpenCAPI 3.1 Transaction and Data Layer Architecture Specification . The design was developed to be used in an \" Apollo \" card. This \" Apollo \" card was developed for use in doing post-silicon validation of OMI memory buffers as well as various DDIMM provider without the need for having an actual processor piece of silicon to drive the OMI traffic. A branch \" vcu128_enablement \" has been created to allow usage of Fire in a VCU128 board with a FMC+ connector and an adaptation board. Check for enablement information on the enablement page","title":"Description"},{"location":"blocs/gemini/","text":"Gemini Description Description Gemini is a development card hosting an ICE OMI device side FPGA reference design and connected to a server DIMM connector. It enables attachment of a DDR4 memory through OMI. It was developed for use in doing post-silicon validation of a CPU that has OMI near memory controller implementations.","title":"GEMINI Card (Device) Description"},{"location":"blocs/gemini/#gemini-description","text":"","title":"Gemini Description"},{"location":"blocs/gemini/#description","text":"Gemini is a development card hosting an ICE OMI device side FPGA reference design and connected to a server DIMM connector. It enables attachment of a DDR4 memory through OMI. It was developed for use in doing post-silicon validation of a CPU that has OMI near memory controller implementations.","title":"Description"},{"location":"blocs/ice/","text":"ICE Description Description Ice is an OMI device side FPGA reference design based on the OpenCAPI 3.1 Transaction and Data Layer Architecture Specification . The design was developed to be used in an \" Gemini \" card. This \" Gemini \" card was developed for use in doing post-silicon validation of a CPU that has OMI near memory controller implementations.","title":"ICE Device Side FPGA Description"},{"location":"blocs/ice/#ice-description","text":"","title":"ICE Description"},{"location":"blocs/ice/#description","text":"Ice is an OMI device side FPGA reference design based on the OpenCAPI 3.1 Transaction and Data Layer Architecture Specification . The design was developed to be used in an \" Gemini \" card. This \" Gemini \" card was developed for use in doing post-silicon validation of a CPU that has OMI near memory controller implementations.","title":"Description"},{"location":"blocs/python/","text":"Python Enablement Software Description Architecture Details OMI enablement platform requires software to configure/synchronize/exercise the host and the DDIMMs modules. Initial development was performed using IBM's Cronus tool and can still be used if required. To ease the discovery of OMI technology, a simple python code has been developed. It can be run either on a external Raspberry pi, or any computer providing an I2C acces to the VCU128 card or on an internal Microblaze microprocessor (under development) Requirements \"click\" and \"smbus2\" librairies are required. General knowledge of python configuration on chosen hardware/OS as well as I2C skills are required. Source code is available here General Preparation and Settings This application is run from CLI (Command Line Interface) with Python3: python3 omi.py --help For a verbose display of any command, add the --log option just after omi.py python3 omi.py --log yourcommand With any command, the I2C bus can be provided with -b option. By default I2C bus is set to 3 if not given. If you are using a different I2C bus number, the number should be passed like this: python3 omi.py anycommand -b 1 You can scan the I2C bus with the command: python3 omi.py scan -b 3 Warning ! Code is provided as is, if unexpected I2C lanes hangs occur, a complete reset of Fire might be required Adapter card Mux settings To be able to access a ddimm from I2C, muxes need to be configured: python3 omi.py initpath -d ddimm # ddimm : I2C selected DDIMM . Can be a,b,none. python3 omi.py initpath -d a python3 omi.py initpath -d b python3 omi.py initpath -d none At any time, you can check the current path already set up with: python3 omi.py checkpath Initialize device Before using the following functions, use the following command to initialize the host, without it, i2c errors will be encountered: python3 omi.py init Host/device information To print out information about a chip, just do: python3 omi.py info -c chip # chip: host/device name. Can be either \"fire\" or \"explorer\" (or \"ice\") python3 omi.py info -c fire python3 omi.py info -c explorer python3 omi.py info -c ice Reseting Device Change reset state of a DDIMM or multiple DDIMMs from fire: python3 omi.py ddimmreset -d ddimms -s newresetstate ddimms: letters of ddimms selected (Examples: abcdsw, ab, a) newresetstate: on to activate reset mode, off to quit reset mode Example python3 omi.py ddimmreset -d ab -s on Read a host/device register: python3 omi.py read -c chip -r regaddr chip: chip name. Can be either fire or explorer (or ice) regaddr: register address given in hex python3 omi.py read -c fire -r 0x100000000000004 python3 omi.py read -c explorer -r 0x20b080 python3 omi.py read -c explorer -r 0x8012811 Write to a host/device register: python3 omi.py write -c chip -r regaddr -d data chip: chip name. Can be either fire or explorer (or ice) regaddr: register address given in hex data: new value to write to the register, in hex python3 omi.py write -c fire -r 0x100000000000004 -d 0x3f python3 omi.py write -c explorer -r 0x8012811 -d 0x5000000006f Trigger training/synchronisation procedure: python3 omi.py sync -d ddimms ddimms: letters of ddimms to sync (Examples: ab, b, a) !! This function commutes the muxes automatically to sync the ddims provided. !! Make sure to wait for about 20s after powering/resetting devices before launchig this command, !! otherwise it fails and needs to be re-executed. python3 omi.py sync -d a python3 omi.py sync -d b python3 omi.py sync -d ab Trigger DDIMM Configuration procedure: python3 omi.py ddimmcfg -d ddimms ddimms: letters of ddimms to sync (Examples: ab, b, a) This function will trigger a configuration process with Fire commands (Explorer will be accessed through In-band commands) No need to select the MUX path, as only Fire receives I2C commands. python3 omi.py ddimmcfg -d a python3 omi.py ddimmcfg -d b python3 omi.py ddimmcfg -d ab To check DDIMM training state: python3 omi.py checksync -d ddimms ddimms: letters of ddimms to sync check (Examples: ab, b, a) python3 omi.py checksync -d a python3 omi.py checksync -d b python3 omi.py checksync -d ab Examples of Usage python3 omi.py initpath -d a python3 omi.py init python3 omi.py sync -d a python3 omi.py info -c explorer python3 omi.py checkpath pi@raspberrypi:~/python $ python3 omi.py initpath -d a pi@raspberrypi:~/python $ python3 omi.py init pi@raspberrypi:~/python $ python3 omi.py sync -d a ---------- : Explorer Initialisation ------------ Explorer Firmware API version: 0x0f Ready Sync DDIMMA... ---------- Explorer OMI Training Sequence ------------ ---------- Fire OMI Training Sequence ------------ DDIMMA sync Reg: 0x8000000000 Training successfully done. pi@raspberrypi:~/python $ python3 omi.py ddimmcfg -d a Configuring DDIMMA... DDIMMA Configuration Memory Size : 64GB Vendor : SMART Memory Size : 64GB Vendor : SMART pi@raspberrypi:~/python $ python3 omi.py info -c explorer FW number of images: 0x2 Partition ID: 0x41 Major (Boot Partion A): 0x8 Minor (Boot Partion A): 0x0 Build patch (Boot Partion A): 0x0 Build number (Boot Partion A): 0x6792a Build date (Boot Partion A): 0x2222021 Major (Boot Partion B): 0x8 Minor (Boot Partion B): 0x0 Build patch (Boot Partion B): 0x0 Build number (Boot Partion B): 0x6792a Build date (Boot Partion B): 0x2222021 RAM size (in bytes): 0x40000 Chip version: 0x20600d2 SPI flash ID: 0xbb98 SPI flash sector size: 0x10000 SPI flash size: 0x1000000 Error buffer size: 0x1000 Image index: 0x0 ECID: 0x1000000000000721a6d03b4f8759f0d4ed89300 Entreprise Mode Status: 0x796 Card ID: 0x3e00008 EEPROM data: Reading 0x40c0a8529000800600003080b8000 Memory Size : 32GB","title":"Python Enablement Software Description"},{"location":"blocs/python/#python-enablement-software-description","text":"","title":"Python Enablement Software Description"},{"location":"blocs/python/#architecture-details","text":"OMI enablement platform requires software to configure/synchronize/exercise the host and the DDIMMs modules. Initial development was performed using IBM's Cronus tool and can still be used if required. To ease the discovery of OMI technology, a simple python code has been developed. It can be run either on a external Raspberry pi, or any computer providing an I2C acces to the VCU128 card or on an internal Microblaze microprocessor (under development)","title":"Architecture Details"},{"location":"blocs/python/#requirements","text":"\"click\" and \"smbus2\" librairies are required. General knowledge of python configuration on chosen hardware/OS as well as I2C skills are required. Source code is available here","title":"Requirements"},{"location":"blocs/python/#general-preparation-and-settings","text":"This application is run from CLI (Command Line Interface) with Python3: python3 omi.py --help For a verbose display of any command, add the --log option just after omi.py python3 omi.py --log yourcommand With any command, the I2C bus can be provided with -b option. By default I2C bus is set to 3 if not given. If you are using a different I2C bus number, the number should be passed like this: python3 omi.py anycommand -b 1 You can scan the I2C bus with the command: python3 omi.py scan -b 3 Warning ! Code is provided as is, if unexpected I2C lanes hangs occur, a complete reset of Fire might be required","title":"General Preparation and Settings"},{"location":"blocs/python/#adapter-card-mux-settings","text":"To be able to access a ddimm from I2C, muxes need to be configured: python3 omi.py initpath -d ddimm # ddimm : I2C selected DDIMM . Can be a,b,none. python3 omi.py initpath -d a python3 omi.py initpath -d b python3 omi.py initpath -d none At any time, you can check the current path already set up with: python3 omi.py checkpath","title":"Adapter card Mux settings"},{"location":"blocs/python/#initialize-device","text":"Before using the following functions, use the following command to initialize the host, without it, i2c errors will be encountered: python3 omi.py init","title":"Initialize device"},{"location":"blocs/python/#hostdevice-information","text":"To print out information about a chip, just do: python3 omi.py info -c chip # chip: host/device name. Can be either \"fire\" or \"explorer\" (or \"ice\") python3 omi.py info -c fire python3 omi.py info -c explorer python3 omi.py info -c ice","title":"Host/device information"},{"location":"blocs/python/#reseting-device","text":"","title":"Reseting Device"},{"location":"blocs/python/#change-reset-state-of-a-ddimm-or-multiple-ddimms-from-fire","text":"python3 omi.py ddimmreset -d ddimms -s newresetstate ddimms: letters of ddimms selected (Examples: abcdsw, ab, a) newresetstate: on to activate reset mode, off to quit reset mode","title":"Change reset state of a DDIMM or multiple DDIMMs from fire:"},{"location":"blocs/python/#example","text":"python3 omi.py ddimmreset -d ab -s on","title":"Example"},{"location":"blocs/python/#read-a-hostdevice-register","text":"python3 omi.py read -c chip -r regaddr chip: chip name. Can be either fire or explorer (or ice) regaddr: register address given in hex python3 omi.py read -c fire -r 0x100000000000004 python3 omi.py read -c explorer -r 0x20b080 python3 omi.py read -c explorer -r 0x8012811","title":"Read a host/device register:"},{"location":"blocs/python/#write-to-a-hostdevice-register","text":"python3 omi.py write -c chip -r regaddr -d data chip: chip name. Can be either fire or explorer (or ice) regaddr: register address given in hex data: new value to write to the register, in hex python3 omi.py write -c fire -r 0x100000000000004 -d 0x3f python3 omi.py write -c explorer -r 0x8012811 -d 0x5000000006f","title":"Write to a host/device register:"},{"location":"blocs/python/#trigger-trainingsynchronisation-procedure","text":"python3 omi.py sync -d ddimms ddimms: letters of ddimms to sync (Examples: ab, b, a) !! This function commutes the muxes automatically to sync the ddims provided. !! Make sure to wait for about 20s after powering/resetting devices before launchig this command, !! otherwise it fails and needs to be re-executed. python3 omi.py sync -d a python3 omi.py sync -d b python3 omi.py sync -d ab","title":"Trigger training/synchronisation procedure:"},{"location":"blocs/python/#trigger-ddimm-configuration-procedure","text":"python3 omi.py ddimmcfg -d ddimms ddimms: letters of ddimms to sync (Examples: ab, b, a) This function will trigger a configuration process with Fire commands (Explorer will be accessed through In-band commands) No need to select the MUX path, as only Fire receives I2C commands. python3 omi.py ddimmcfg -d a python3 omi.py ddimmcfg -d b python3 omi.py ddimmcfg -d ab","title":"Trigger DDIMM Configuration procedure:"},{"location":"blocs/python/#to-check-ddimm-training-state","text":"python3 omi.py checksync -d ddimms ddimms: letters of ddimms to sync check (Examples: ab, b, a) python3 omi.py checksync -d a python3 omi.py checksync -d b python3 omi.py checksync -d ab","title":"To check DDIMM training state:"},{"location":"blocs/python/#examples-of-usage","text":"python3 omi.py initpath -d a python3 omi.py init python3 omi.py sync -d a python3 omi.py info -c explorer python3 omi.py checkpath pi@raspberrypi:~/python $ python3 omi.py initpath -d a pi@raspberrypi:~/python $ python3 omi.py init pi@raspberrypi:~/python $ python3 omi.py sync -d a ---------- : Explorer Initialisation ------------ Explorer Firmware API version: 0x0f Ready Sync DDIMMA... ---------- Explorer OMI Training Sequence ------------ ---------- Fire OMI Training Sequence ------------ DDIMMA sync Reg: 0x8000000000 Training successfully done. pi@raspberrypi:~/python $ python3 omi.py ddimmcfg -d a Configuring DDIMMA... DDIMMA Configuration Memory Size : 64GB Vendor : SMART Memory Size : 64GB Vendor : SMART pi@raspberrypi:~/python $ python3 omi.py info -c explorer FW number of images: 0x2 Partition ID: 0x41 Major (Boot Partion A): 0x8 Minor (Boot Partion A): 0x0 Build patch (Boot Partion A): 0x0 Build number (Boot Partion A): 0x6792a Build date (Boot Partion A): 0x2222021 Major (Boot Partion B): 0x8 Minor (Boot Partion B): 0x0 Build patch (Boot Partion B): 0x0 Build number (Boot Partion B): 0x6792a Build date (Boot Partion B): 0x2222021 RAM size (in bytes): 0x40000 Chip version: 0x20600d2 SPI flash ID: 0xbb98 SPI flash sector size: 0x10000 SPI flash size: 0x1000000 Error buffer size: 0x1000 Image index: 0x0 ECID: 0x1000000000000721a6d03b4f8759f0d4ed89300 Entreprise Mode Status: 0x796 Card ID: 0x3e00008 EEPROM data: Reading 0x40c0a8529000800600003080b8000 Memory Size : 32GB","title":"Examples of Usage"},{"location":"misc/doc-guide/","text":"How to generate this website This static documentation website is created by MkDocs and is using a theme from bootswatch . It uses \"github pages\" and this site is hosted by Github. The documentation source files are written in Markdown format. With MkDocs tool, the generated site files (html files) are automatically pushed into a specific branch gh-pages of the git repository. Installation 1. Install python and pip python and pip 2. Install mkdocs-bootswatch pip install mkdocs-bootswatch Please refer to bootswatch for more information. 3. Install a markdown editor You can simply edit the markdown (.md) files by any text editor, but it's better to user a professional markdown editor. typora . It supports all of the platforms (Windows/MacOS/Linux). Please configure typora to strict Markdown mode. That ensures you get the same output effects on both typora and mkdocs . vscode . It's also a good editor and has abundant functions and extensions. You can install extensions of Markdown, Preview and Spell checker. 4. Install other optional tools pdf2svg: This tool can convert a pdf lossless picture to svg format. For Mac OS, it can be easily installed by Homebrew , simply by brew install pdf2svg . Alternative choice is Inkscape which is a free drawing tool and can help you draw and convert vector graphics. Website Structure First, you need to git clone the omi-doc repository and go to web-doc directory. Make sure you are working on a branch other than master. $ git clone git@github.com:OpenCAPI/omi-doc.git $ cd omi-doc/web-doc Create a branch if needed: $ git branch <new-branch-name> $ git checkout <A branch other than master> The docs folder is where to put the markdown files, and the mkdocs.yml lists the website structure and global definitons. For example, this site has a structure like: nav: - Main Elements: - 'Overview': 'index.md' - 'FIRE Description': 'blocs/fire.md' - 'ICE Description': 'blocs/ice.md' - 'GEMINI Description': 'blocs/gemini.md' - 'FMC+ ENABLEMENT Description': 'blocs/enablement.md' - Misc: - 'Document Guide': 'misc/doc-guide.md' You can edit them as needed. Write Markdown pages On your local desktop, edit markdown files under web-doc/docs folder. If you want to add/delete/rename the files, you also need to edit mkdocs.yml Now it's time to work with an editor (i.e, typora) to write the documents. You also may need to learn some markdown syntax. Don't worry, that's easy. And please turn on the \"spell checking\" in your Markdown editor. In your terminal (MacOS or Linux), or cmd (Windows), start a serve process: # enter in the directory where mkdocs.yml is located cd ~/omi-doc/web-doc #launch a local webserver to test your mods mkdocs serve Then open a web browser, input http://127.0.0.1:8000 . So whenever you save any markdown files, you can check the generated website immediately. Play with pictures The first rule Reduce the usage of pictures. Avoid unnecessary screenshots. It's quite easy You can insert jpg, png, svg files. You can also simply copy paste pictures from clipboard and paste them. Copy the files into a directory ./${filename}.assets , and here ${filename} is the name of markdown file. Use relative links in the document. Note If you are using Typora, please enable \"Copy images into ./${filename}.assets folder\" in Preferences of typora. Tools to draw diagrams You can take any drawing tools to create diagrams. You can save them as PNG format, but the better way is to save to SVG format. For the diagrams from Microsoft PowerPoint, you can select the region of a diagram in PPT, Ctrl-C to copy it, and Ctrl-V to paste it in Typora directly. In this case, the diagram is saved as an PNG file. But there is a better way to get the smallest file size and best quality: In PowerPoint, select the region of diagram, right-click mouse -> \"Save as Picture ...\" and save it as \"PDF\" format. Open the PDF file with Inkscape . (Right-click the file -> \"Open with ...\", choose Inkscape in the poped up list). Unclick \"Embed images\" and then \"OK\". In Inkscape, save it as SVG file. Insert the SVG file into Typora. In my experiment, the PNG file is 188KB. But with the above flow to save it as SVG file, its size is 62KB. As a vectored diagram, it doesn't have any quality loss when zooming in. Warning Please use normal fonts in PPT, for example \"Arial\". Otherwise you may get a SVG file with a replaced font and that may look different. Code blocks and Admonitions Code blocks Please assign the code language so it can be correctly rendered. For example ``` C for C language. // A function to implement bubble sort void bubbleSort(int arr[], int n) { int i, j; for (i = 0; i < n-1; i++) // Last i elements are already in place for (j = 0; j < n-i-1; j++) if (arr[j] > arr[j+1]) swap(&arr[j], &arr[j+1]); } Admonitions You can use !!! Note or !!! Warning or !!! Danger to start a paragraph of admonitions. Then use 4 spaces to start the admonition text. For example !!! Danger \"Error Message\" This is a dangerous error. It will be shown as: Error Message This is a dangerous error. Deploy to Github Pages When most of the edition work is done, and it's time to commit your documents to omi-doc github. First, you should commit and push your changes of source files (in web-doc ) to git repository. Create pull request, ask someone to review the documents, merge them into master branch after getting approvements. Then you can simply publish website with just one step: cd <PATH>/omi-doc/web-doc mkdocs gh-deploy The entire website will be pushed to gh-pages branch of omi-doc repository. The documentation website will be available at https://opencapi.github.io/omi-doc/ !","title":"Document Guide"},{"location":"misc/doc-guide/#how-to-generate-this-website","text":"This static documentation website is created by MkDocs and is using a theme from bootswatch . It uses \"github pages\" and this site is hosted by Github. The documentation source files are written in Markdown format. With MkDocs tool, the generated site files (html files) are automatically pushed into a specific branch gh-pages of the git repository.","title":"How to generate this website"},{"location":"misc/doc-guide/#installation","text":"","title":"Installation"},{"location":"misc/doc-guide/#1-install-python-and-pip","text":"python and pip","title":"1. Install python and pip"},{"location":"misc/doc-guide/#2-install-mkdocs-bootswatch","text":"pip install mkdocs-bootswatch Please refer to bootswatch for more information.","title":"2. Install mkdocs-bootswatch"},{"location":"misc/doc-guide/#3-install-a-markdown-editor","text":"You can simply edit the markdown (.md) files by any text editor, but it's better to user a professional markdown editor. typora . It supports all of the platforms (Windows/MacOS/Linux). Please configure typora to strict Markdown mode. That ensures you get the same output effects on both typora and mkdocs . vscode . It's also a good editor and has abundant functions and extensions. You can install extensions of Markdown, Preview and Spell checker.","title":"3. Install a markdown editor"},{"location":"misc/doc-guide/#4-install-other-optional-tools","text":"pdf2svg: This tool can convert a pdf lossless picture to svg format. For Mac OS, it can be easily installed by Homebrew , simply by brew install pdf2svg . Alternative choice is Inkscape which is a free drawing tool and can help you draw and convert vector graphics.","title":"4. Install other optional tools"},{"location":"misc/doc-guide/#website-structure","text":"First, you need to git clone the omi-doc repository and go to web-doc directory. Make sure you are working on a branch other than master. $ git clone git@github.com:OpenCAPI/omi-doc.git $ cd omi-doc/web-doc Create a branch if needed: $ git branch <new-branch-name> $ git checkout <A branch other than master> The docs folder is where to put the markdown files, and the mkdocs.yml lists the website structure and global definitons. For example, this site has a structure like: nav: - Main Elements: - 'Overview': 'index.md' - 'FIRE Description': 'blocs/fire.md' - 'ICE Description': 'blocs/ice.md' - 'GEMINI Description': 'blocs/gemini.md' - 'FMC+ ENABLEMENT Description': 'blocs/enablement.md' - Misc: - 'Document Guide': 'misc/doc-guide.md' You can edit them as needed.","title":"Website Structure"},{"location":"misc/doc-guide/#write-markdown-pages","text":"On your local desktop, edit markdown files under web-doc/docs folder. If you want to add/delete/rename the files, you also need to edit mkdocs.yml Now it's time to work with an editor (i.e, typora) to write the documents. You also may need to learn some markdown syntax. Don't worry, that's easy. And please turn on the \"spell checking\" in your Markdown editor. In your terminal (MacOS or Linux), or cmd (Windows), start a serve process: # enter in the directory where mkdocs.yml is located cd ~/omi-doc/web-doc #launch a local webserver to test your mods mkdocs serve Then open a web browser, input http://127.0.0.1:8000 . So whenever you save any markdown files, you can check the generated website immediately.","title":"Write Markdown pages"},{"location":"misc/doc-guide/#play-with-pictures","text":"","title":"Play with pictures"},{"location":"misc/doc-guide/#the-first-rule","text":"Reduce the usage of pictures. Avoid unnecessary screenshots.","title":"The first rule"},{"location":"misc/doc-guide/#its-quite-easy","text":"You can insert jpg, png, svg files. You can also simply copy paste pictures from clipboard and paste them. Copy the files into a directory ./${filename}.assets , and here ${filename} is the name of markdown file. Use relative links in the document. Note If you are using Typora, please enable \"Copy images into ./${filename}.assets folder\" in Preferences of typora.","title":"It's quite easy"},{"location":"misc/doc-guide/#tools-to-draw-diagrams","text":"You can take any drawing tools to create diagrams. You can save them as PNG format, but the better way is to save to SVG format. For the diagrams from Microsoft PowerPoint, you can select the region of a diagram in PPT, Ctrl-C to copy it, and Ctrl-V to paste it in Typora directly. In this case, the diagram is saved as an PNG file. But there is a better way to get the smallest file size and best quality: In PowerPoint, select the region of diagram, right-click mouse -> \"Save as Picture ...\" and save it as \"PDF\" format. Open the PDF file with Inkscape . (Right-click the file -> \"Open with ...\", choose Inkscape in the poped up list). Unclick \"Embed images\" and then \"OK\". In Inkscape, save it as SVG file. Insert the SVG file into Typora. In my experiment, the PNG file is 188KB. But with the above flow to save it as SVG file, its size is 62KB. As a vectored diagram, it doesn't have any quality loss when zooming in. Warning Please use normal fonts in PPT, for example \"Arial\". Otherwise you may get a SVG file with a replaced font and that may look different.","title":"Tools to draw diagrams"},{"location":"misc/doc-guide/#code-blocks-and-admonitions","text":"","title":"Code blocks and Admonitions"},{"location":"misc/doc-guide/#code-blocks","text":"Please assign the code language so it can be correctly rendered. For example ``` C for C language. // A function to implement bubble sort void bubbleSort(int arr[], int n) { int i, j; for (i = 0; i < n-1; i++) // Last i elements are already in place for (j = 0; j < n-i-1; j++) if (arr[j] > arr[j+1]) swap(&arr[j], &arr[j+1]); }","title":"Code blocks"},{"location":"misc/doc-guide/#admonitions","text":"You can use !!! Note or !!! Warning or !!! Danger to start a paragraph of admonitions. Then use 4 spaces to start the admonition text. For example !!! Danger \"Error Message\" This is a dangerous error. It will be shown as: Error Message This is a dangerous error.","title":"Admonitions"},{"location":"misc/doc-guide/#deploy-to-github-pages","text":"When most of the edition work is done, and it's time to commit your documents to omi-doc github. First, you should commit and push your changes of source files (in web-doc ) to git repository. Create pull request, ask someone to review the documents, merge them into master branch after getting approvements. Then you can simply publish website with just one step: cd <PATH>/omi-doc/web-doc mkdocs gh-deploy The entire website will be pushed to gh-pages branch of omi-doc repository. The documentation website will be available at https://opencapi.github.io/omi-doc/ !","title":"Deploy to Github Pages"}]}